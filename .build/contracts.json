{"contracts":{"contracts/InterestRateModel.sol:InterestRateModel":{"abi":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"yOffset_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slopeFactor_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateFactorSensitivity_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBase_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeSensitivity_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"range_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"feeBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeSensitivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplierLiquidityUnderlying\",\"type\":\"uint256\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"rateFactorPrev\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplierLiquidityUnderlying\",\"type\":\"uint256\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rateFactorNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"range\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateFactorSensitivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slopeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","bin":"61014060405234801561001157600080fd5b50604051610c38380380610c38833981810160405260c081101561003457600080fd5b508051602082015160408301516060840151608085015160a090950151939492939192909184158015906100685750600084115b80156100745750600081115b6100c5576040805162461bcd60e51b815260206004820152601760248201527f5a65726f20706172616d73206e6f7420616c6c6f776564000000000000000000604482015290519081900360640190fd5b608086905260a085905260c084905261010083905261012082905260e08190529190610afe61013a6000398061034c52806103c052508061030452806103995250806101ed52806103f552508061019852806102e0525080610226528061032852508061026552806103705250610afe6000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063cd2ccf9f1161005b578063cd2ccf9f14610107578063cf31f14f1461010f578063d250185c14610117578063e97206a91461013a57610088565b806327fc00241461008d57806358f40173146100dd57806395e911a8146100f7578063a11a65b6146100ff575b600080fd5b6100c4600480360360a08110156100a357600080fd5b50803590602081013515159060408101359060608101359060800135610142565b6040805192835260208301919091528051918290030190f35b6100e56102de565b60408051918252519081900360200190f35b6100e5610302565b6100e5610326565b6100e561034a565b6100e561036e565b6100e56004803603604081101561012d57600080fd5b5080359060200135610392565b6100e56103f3565b6000808261018e576040805162461bcd60e51b81526020600482015260146024820152730737570706c696564206c697175696469747920360641b604482015290519081900360640190fd5b60006101c36101bd7f000000000000000000000000000000000000000000000000000000000000000088610417565b85610470565b9050866101d9576101d488826104da565b6101e3565b6101e3888261052b565b91506000610211837f000000000000000000000000000000000000000000000000000000000000000061057c565b9050600061024f61024a610224866105cd565b7f00000000000000000000000000000000000000000000000000000000000000006105e1565b61063b565b9050600061028e610289610263858561068c565b7f000000000000000000000000000000000000000000000000000000000000000061052b565b6106dd565b9050600061029c8989610392565b90508a156102b5576102ae82826105e1565b96506102cf565b808211156102c7576102ae82826106f1565b600096508b95505b50505050509550959350505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b60006103ea7f00000000000000000000000000000000000000000000000000000000000000006103e56101bd7f000000000000000000000000000000000000000000000000000000000000000087610417565b6105e1565b90505b92915050565b7f000000000000000000000000000000000000000000000000000000000000000081565b600082610426575060006103ed565b8282028284828161043357fe5b04146103ea5760405162461bcd60e51b8152600401808060200182810382526021815260200180610aa86021913960400191505060405180910390fd5b60008082116104c6576040805162461bcd60e51b815260206004820152601860248201527f536166654d6174683a20446976696465206279207a65726f0000000000000000604482015290519081900360640190fd5b60008284816104d157fe5b04949350505050565b60006001600160ff1b0382106105215760405162461bcd60e51b815260040180806020018281038252602b815260200180610993602b913960400191505060405180910390fd5b6103ea8383610746565b60006001600160ff1b0382106105725760405162461bcd60e51b8152600401808060200182810382526028815260200180610a076028913960400191505060405180910390fd5b6103ea83836107ab565b60006001600160ff1b0382106105c35760405162461bcd60e51b815260040180806020018281038252602e815260200180610a2f602e913960400191505060405180910390fd5b6103ea8383610810565b60006105d98283610810565b90505b919050565b6000828201838110156103ea576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b6000600382111561067e575080600160028204015b818110156106785780915060028182858161066757fe5b04018161067057fe5b049050610650565b506105dc565b81156105dc57506001919050565b60006001600160ff1b0382106106d35760405162461bcd60e51b81526004018080602001828103825260288152602001806109be6028913960400191505060405180910390fd5b6103ea83836108b9565b60008082136106ed5760006105d9565b5090565b600082821115610740576040805162461bcd60e51b81526020600482015260156024820152747375627472616374696f6e20756e646572666c6f7760581b604482015290519081900360640190fd5b50900390565b600081830381831280159061075b5750838113155b80610770575060008312801561077057508381135b6103ea5760405162461bcd60e51b8152600401808060200182810382526024815260200180610a846024913960400191505060405180910390fd5b60008282018183128015906107c05750838112155b806107d557506000831280156107d557508381125b6103ea5760405162461bcd60e51b81526004018080602001828103825260218152602001806109726021913960400191505060405180910390fd5b60008261081f575060006103ed565b826000191480156108335750600160ff1b82145b1561086f5760405162461bcd60e51b8152600401808060200182810382526027815260200180610a5d6027913960400191505060405180910390fd5b8282028284828161087c57fe5b05146103ea5760405162461bcd60e51b8152600401808060200182810382526027815260200180610a5d6027913960400191505060405180910390fd5b60008161090d576040805162461bcd60e51b815260206004820181905260248201527f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f604482015290519081900360640190fd5b816000191480156109215750600160ff1b83145b1561095d5760405162461bcd60e51b81526004018080602001828103825260218152602001806109e66021913960400191505060405180910390fd5b600082848161096857fe5b0594935050505056fe5369676e6564536166654d6174683a206164646974696f6e206f766572666c6f77536166654d6174683a20496e74207375627472616374696f6e206f766572666c6f77206465746563746564536166654d6174683a20496e74206469766973696f6e206f766572666c6f772064657465637465645369676e6564536166654d6174683a206469766973696f6e206f766572666c6f77536166654d6174683a20496e74206164646974696f6e206f766572666c6f77206465746563746564536166654d6174683a20496e74206d756c7469706c69636174696f6e206f766572666c6f772064657465637465645369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77536166654d6174683a204d756c7469706c69636174696f6e206f766572666c6f77a2646970667358221220fddf142a73379224df047578dd78bcc1290ca0ba9a12a6b8fcd3572bedb144b464736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"yOffset_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slopeFactor_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateFactorSensitivity_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBase_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeSensitivity_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"range_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"feeBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeSensitivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplierLiquidityUnderlying\",\"type\":\"uint256\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"rateFactorPrev\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplierLiquidityUnderlying\",\"type\":\"uint256\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rateFactorNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"range\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateFactorSensitivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slopeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/InterestRateModel.sol\":\"InterestRateModel\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/InterestRateModel.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport {InterestRateModelInterface} from \\\"./RhoInterfaces.sol\\\";\\n\\ncontract InterestRateModel is InterestRateModelInterface {\\n\\n\\tuint public immutable yOffset;\\n\\tuint public immutable slopeFactor;\\n\\tuint public immutable rateFactorSensitivity;\\n\\tuint public immutable range;\\n\\tuint public immutable feeBase;\\n\\tuint public immutable feeSensitivity;\\n\\n\\tconstructor(\\n\\t\\tuint yOffset_,\\n\\t\\tuint slopeFactor_,\\n\\t\\tuint rateFactorSensitivity_,\\n\\t\\tuint feeBase_,\\n\\t\\tuint feeSensitivity_,\\n\\t\\tuint range_\\n\\t) public {\\n\\t\\trequire(slopeFactor_ > 0 && rateFactorSensitivity_ > 0 && range_ > 0 , \\\"Zero params not allowed\\\");\\n\\n\\t\\tyOffset = yOffset_;\\n\\t\\tslopeFactor = slopeFactor_;\\n\\t\\trateFactorSensitivity = rateFactorSensitivity_;\\n\\t\\tfeeBase = feeBase_;\\n\\t\\tfeeSensitivity = feeSensitivity_;\\n\\t\\trange = range_;\\n\\t}\\n\\n\\t/* @dev Calculates the per-block interest rate to offer an incoming swap based on the rateFactor stored in Rho.sol.\\n\\t * @param userPayingFixed : If the user is paying fixed in incoming swap\\n\\t * @param orderNotional : Notional order size of the incoming swap\\n\\t * @param lockedCollateralUnderlying : The amount of the protocol's liquidity that is locked at the time of the swap in underlying tokens\\n\\t * @param supplierLiquidityUnderlying : Total amount of the protocol's liquidity in underlying tokens\\n\\t */\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external override view returns (uint rate, int rateFactorNew) {\\n\\t\\trequire(supplierLiquidityUnderlying != 0, \\\"supplied liquidity 0\\\");\\n\\t\\tuint rfDelta = div(mul(rateFactorSensitivity, orderNotional), supplierLiquidityUnderlying);\\n\\t\\trateFactorNew = userPayingFixed ? add(rateFactorPrev, rfDelta) : sub(rateFactorPrev, rfDelta);\\n\\n\\t\\tint num = mul(rateFactorNew, range);\\n\\t\\tuint denom = sqrt(add(square(rateFactorNew), slopeFactor));\\n\\n\\t\\tuint baseRate = toZero(add(div(num, denom), yOffset)); // can not be negative\\n\\t\\tuint fee = getFee(lockedCollateralUnderlying, supplierLiquidityUnderlying);\\n\\n\\t\\t// base + yOffset +- fee\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\trate = add(baseRate, fee);\\n\\t\\t} else {\\n\\t\\t\\tif (baseRate > fee) {\\n\\t\\t\\t\\trate = sub(baseRate, fee);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trate = 0;\\n\\t\\t\\t\\t// if the rate is negative, don't push rate factor even lower\\n\\t\\t\\t\\trateFactorNew = rateFactorPrev;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// @dev Calculates the fee to add to the rate. fee = feeBase + feeSensitivity * locked / total\\n\\tfunction getFee(uint lockedCollateralUnderlying, uint supplierLiquidityUnderlying) public view returns (uint) {\\n\\t\\treturn add(feeBase, div(mul(feeSensitivity, lockedCollateralUnderlying), supplierLiquidityUnderlying));\\n\\t}\\n\\n    // ** Interest Rate Model Math Library **//\\n\\n    // Source: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n\\t// ** UINT SAFE MATH ** //\\n\\t// Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\\n\\n\\tfunction mul(uint a, uint b) internal pure returns (uint) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, \\\"SafeMath: Multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint a, uint b) internal pure returns (uint) {\\n        require(b > 0, \\\"SafeMath: Divide by zero\\\");\\n        uint c = a / b;\\n        return c;\\n    }\\n\\n    function add(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint a, uint b) pure internal returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n   \\t// ** INT SAFE MATH ** //\\n   \\t// Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SignedSafeMath.sol\\n\\tint constant private _INT_MIN = -2**255;\\n\\n    function div(int a, int b) internal pure returns (int) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int c = a / b;\\n\\n        return c;\\n    }\\n\\n    function mul(int a, int b) internal pure returns (int) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function add(int a, int b) internal pure returns (int) {\\n        int c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n   \\t// ** INT => UINT MATH ** //\\n\\n   \\t// Set negative ints to 0\\n    function toZero(int x) internal pure returns (uint) {\\n\\t\\treturn x > 0 ? uint(x) : 0;\\n\\t}\\n\\n\\tfunction square(int a) internal pure returns (uint) {\\n\\t\\treturn uint(mul(a, a));\\n\\t}\\n\\n\\t// ** UINT => INT MATH ** //\\n\\n\\tint constant private _INT_MAX = 2**255 - 1;\\n\\n    function add(int a, uint b) internal pure returns (int){\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int addition overflow detected\\\");\\n        return add(a, int(b));\\n    }\\n\\n\\tfunction mul(int a, uint b) internal pure returns (int) {\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int multiplication overflow detected\\\");\\n        return mul(a, int(b));\\n\\t}\\n\\n    function sub(int a, uint b) internal pure returns (int){\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int subtraction overflow detected\\\");\\n        return sub(a, int(b));\\n    }\\n\\n\\tfunction div(int a, uint b) internal pure returns (int) {\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int division overflow detected\\\");\\n        return div(a, int(b));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x3687e4d83502a5bb22609a621c023285c7a88fbde0317c3d2ad619352f013b09\"},\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"}},\"version\":1}"},"contracts/Math.sol:Math":{"abi":"[]","bin":"60a0604052670de0b6b3a76400006080819052600055348015602057600080fd5b50603f80602e6000396000f3fe6080604052600080fdfea2646970667358221220e911cde56e1634e98f1690231998a0a9183c66bd954643c0e38a8e281c04fee164736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/Math.sol\":\"Math\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Math.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\n/* @dev A safe math lib for Rho data types. \\n   Note: always returns type of left side param */\\ncontract Math is Types {\\n\\n\\tuint constant EXP_SCALE = 1e18;\\n    Exp ONE_EXP = Exp({mantissa: EXP_SCALE});\\n\\n    function _toExp(uint num) pure internal returns (Exp memory) {\\n    \\treturn Exp({mantissa: num});\\n    }\\n\\n    function _toUint(int a) pure internal returns (uint) {\\n        return a > 0 ? uint(a) : 0;\\n    }\\n\\n    function _lt(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val < b.val;\\n    }\\n\\n    function _lte(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val <= b.val;\\n    }\\n\\n    function _add(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _add(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _add(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _add(a.val, b.val)});\\n    }\\n\\n    function _add(uint a, uint b) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function _sub(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _sub(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _subToZero(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        if (b.val >= a.val) {\\n            return CTokenAmount({val: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(uint a, uint b) pure internal returns (uint) {\\n        if (b >= a) {\\n            return 0;\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        if (b.mantissa >= a.mantissa) {\\n            return Exp({mantissa: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _sub(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _sub(a.val, b.val)});\\n    }\\n\\n    function _sub(uint a, uint b) pure internal returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function _sub(int a, uint b) pure internal returns (int) {\\n        int c = a - int(b);\\n        require(a >= c, \\\"int - uint underflow\\\");\\n        return c;\\n    }\\n\\n    function _add(int a, uint b) pure internal returns (int) {\\n        int c = a + int(b);\\n        require(a <= c, \\\"int + uint overflow\\\");\\n        return c;\\n    }\\n\\n    function _mul(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _mul(a, b.val);\\n    }\\n\\n    function _mul(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _mul(a.val, b)});\\n    }\\n\\n    function _mul(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b.mantissa) / EXP_SCALE});\\n    }\\n\\n    function _mul(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b)});\\n    }\\n\\n    function _mul(uint a, Exp memory b) pure internal returns (uint) {\\n        return _mul(a, b.mantissa) / EXP_SCALE;\\n    }\\n\\n    function _mul(uint a, uint b) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function _div(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _div(a, b.val);\\n    }\\n\\n    function _div(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _div(a.val, b)});\\n    }\\n\\n    function _div(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(_mul(a.mantissa, EXP_SCALE), b.mantissa)});\\n    }\\n\\n    function _div(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(a.mantissa, b)});\\n    }\\n\\n    function _div(uint a, Exp memory b) pure internal returns (uint) {\\n        return _div(_mul(a, EXP_SCALE), b.mantissa);\\n    }\\n\\n    function _div(uint a, uint b) pure internal returns (uint) {\\n        require(b > 0, \\\"divide by zero\\\");\\n        return a / b;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x8c6200920feaf6aa32f936d0daf59a94bc84b9b5808c425db8b1eba60bd65e06\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"}},\"version\":1}"},"contracts/Rho.sol:Rho":{"abi":"[{\"inputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"contract CTokenInterface\",\"name\":\"cToken_\",\"type\":\"address\"},{\"internalType\":\"contract CompInterface\",\"name\":\"comp_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapMinDuration_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyMinDuration_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidityLimitCTokens_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplierLiquidityNew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedCollateralNew\",\"type\":\"uint256\"}],\"name\":\"Accrue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AdminRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexFinal\",\"type\":\"uint256\"}],\"name\":\"CloseSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"CompDelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CompTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OpenSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyValue\",\"type\":\"uint256\"}],\"name\":\"Remove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa\",\"type\":\"uint256\"}],\"name\":\"SetCollateralRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldModel\",\"type\":\"address\"}],\"name\":\"SetInterestRateModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"SetLiquidityLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"SetPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLOSE_GRACE_PERIOD_BLOCKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLOSE_PENALTY_PER_BLOCK_MANTISSA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_SWAP_NOTIONAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPPLY_MIN_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_MIN_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"_changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"_delegateComp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused_\",\"type\":\"bool\"}],\"name\":\"_pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa_\",\"type\":\"uint256\"}],\"name\":\"_setCollateralRequirements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"newModel\",\"type\":\"address\"}],\"name\":\"_setInterestRateModel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit_\",\"type\":\"uint256\"}],\"name\":\"_setLiquidityLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_transferComp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRatePaying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRateReceiving\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"benchmarkIndexStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"internalType\":\"contract CTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"comp\",\"outputs\":[{\"internalType\":\"contract CompInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBenchmarkIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExchangeRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accruedBlocks\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getLockedCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"parBlocksReceivingFixedNew\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"parBlocksPayingFixedNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"fixedRate\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getPayFixedInitCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"fixedRate\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getReceiveFixedInitCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accruedBlocks\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"floatRate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getSupplierLiquidity\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidityNew\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidity_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAccrualBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openPayFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openReceiveFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksPayingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksReceivingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateFactor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplierLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyAccounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"toCTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"toUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","bin":"610180604052670de0b6b3a7640000610160819052601481905561010052610bb861012052655af3107a4000610140523480156200003c57600080fd5b506040516200397c3803806200397c8339810160408190526200005f9162000209565b8486106200008a5760405162461bcd60e51b81526004016200008190620002bd565b60405180910390fd5b600080546001600160a01b038b166001600160a01b03199091161790556001600160601b0319606089811b821660805288901b1660a052620000d5866001600160e01b03620001da16565b51600c55620000ed856001600160e01b03620001da16565b51600b5560c084905260e0839052601080546001600160a01b0319166001600160a01b0384811691909117909155601454600d556040805163aa5af0fd60e01b81529051620001a9928b169163aa5af0fd916004808301926020929190829003018186803b1580156200015f57600080fd5b505afa15801562000174573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200019a9190620002a4565b6001600160e01b03620001da16565b516002556010805460ff60a01b19169055604080516020810190915281905260115550620003219650505050505050565b620001e4620001f6565b50604080516020810190915290815290565b6040518060200160405280600081525090565b60008060008060008060008060006101208a8c03121562000228578485fd5b8951620002358162000308565b60208b0151909950620002488162000308565b60408b01519098506200025b8162000308565b8097505060608a0151955060808a0151945060a08a0151935060c08a0151925060e08a01516200028b8162000308565b809250506101008a015190509295985092959850929598565b600060208284031215620002b6578081fd5b5051919050565b6020808252602b908201527f4d696e20666c6f61742072617465206d7573742062652062656c6f77206d617860408201526a20666c6f6174207261746560a81b606082015260800190565b6001600160a01b03811681146200031e57600080fd5b50565b60805160601c60a05160601c60c05160e051610100516101205161014051613598620003e4600039806116835280611886525080611356528061162a528061165252508061107d52806123c1525080610e8252806111a9525080611231528061127a528061145952806115ea5280612151528061229c528061274252806128225250806105b0528061070b5280611119525080610ba75280610c605280610d4a52806111d9528061153b52806119e75280611d8b5280611fd352506135986000f3fe608060405234801561001057600080fd5b50600436106102d65760003560e01c80637b38605911610182578063be2e6564116100e9578063e6aa216c116100a2578063f2b3abbd1161007c578063f2b3abbd14610583578063f3fdb15a14610596578063f851a4401461059e578063fa129ad1146105a6576102d6565b8063e6aa216c14610555578063eb84e7f21461055d578063f0b3702114610570576102d6565b8063be2e6564146104eb578063beff7b5b146104f3578063cda7ce0a14610506578063cfba9e0314610519578063e1c326391461053a578063e5505aed1461054d576102d6565b806399c432ee1161013b57806399c432ee1461048d5780639e887fba14610495578063a05e6077146104a8578063a7a3d116146104b0578063ac07293b146104c3578063b187bd26146104d6576102d6565b80637b3860591461045d5780637fb405f01461046557806388369f7e1461046d5780638b72483c1461047557806391a51a401461047d57806398f1bc1214610485576102d6565b806344f94a191161024157806363d6d821116101fa57806372163715116101d457806372163715146104325780637366982c1461043a57806373b8a423146104425780637a8c8d7914610455576102d6565b806363d6d8211461040f57806369e527da146104175780636c7f44da1461041f576102d6565b806344f94a19146103be5780634cc82215146103d1578063504ed5ca146103e45780635568d1bb146103ec57806355b6a697146103ff5780635675da9e14610407576102d6565b806338d2bbc01161029357806338d2bbc01461035c5780633f43955a1461036457806342cbb15c1461036c578063432a8e5d14610374578063432ffe27146103875780634422581d146103a9576102d6565b8063109d0af8146102db5780631152070c146102f95780631f46eaae1461030e578063234d999c14610323578063353dfc01146103365780633540302314610349575b600080fd5b6102e36105ae565b6040516102f09190612bc3565b60405180910390f35b61030c610307366004612985565b6105d2565b005b61031661068d565b6040516102f09190612c9e565b61030c61033136600461293e565b610693565b61030c61034436600461293e565b610775565b61030c610357366004612a87565b610808565b6103166109e3565b6103166109e9565b6103166109ef565b61030c610382366004612a87565b6109f4565b61039a610395366004612b4b565b610a68565b6040516102f0939291906134f2565b6103b1610b92565b6040516102f091906134e8565b6103166103cc366004612a9f565b610dec565b61030c6103df366004612a87565b610e05565b61031661107b565b61030c6103fa36600461295a565b61109f565b6103166111a7565b6103166111cb565b6103166111d1565b6102e36111d7565b6103b161042d366004612ad3565b6111fb565b610316611272565b610316611278565b61030c610450366004612ba2565b61129c565b61031661133c565b610316611342565b610316611348565b61031661134e565b610316611354565b610316611378565b61031661137e565b610316611384565b6103b16104a3366004612ad3565b61138a565b6103166113b5565b61030c6104be366004612a1f565b6113bb565b6103b16104d1366004612b6e565b611786565b6104de611874565b6040516102f09190612c2e565b610316611884565b6103b1610501366004612b4b565b6118a8565b61039a61051436600461293e565b6118d2565b61052c6105273660046129bd565b611901565b6040516102f0929190613509565b610316610548366004612ba2565b6119c6565b6103166119d4565b6103b16119da565b6104de61056b366004612a87565b611a43565b61031661057e366004612ba2565b611a58565b61030c61059136600461293e565b611a66565b6102e3611b25565b6102e3611b34565b610316611b43565b7f000000000000000000000000000000000000000000000000000000000000000081565b6010546001600160a01b031633146106055760405162461bcd60e51b81526004016105fc9061333b565b60405180910390fd5b601060149054906101000a900460ff16151581151514156106385760405162461bcd60e51b81526004016105fc90612dbb565b7f140eb9f8b591138e129e4caf389c92df4f0545b902523eee9e63153ecdb2026e816040516106679190612c2e565b60405180910390a160108054911515600160a01b0260ff60a01b19909216919091179055565b60015481565b6010546001600160a01b031633146106bd5760405162461bcd60e51b81526004016105fc90612cca565b7fa5afd48b94a3b05f17f5a852e09af04691e3a21d9dcff1c6a4c217f2dc5724ed816040516106ec9190612bc3565b60405180910390a16040516317066a5760e21b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690635c19a95c90610740908490600401612bc3565b600060405180830381600087803b15801561075a57600080fd5b505af115801561076e573d6000803e3d6000fd5b5050505050565b6010546001600160a01b0316331461079f5760405162461bcd60e51b81526004016105fc9061328f565b6010546040517f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f916107de916001600160a01b03909116908490612bd7565b60405180910390a1601080546001600160a01b0319166001600160a01b0392909216919091179055565b6108106128c7565b5060408051602081019091528181526108276128c7565b6040805160208101909152600e5481526108419083611b49565b6040805160208101909152601154815290915061085f908290611b77565b61087b5760405162461bcd60e51b81526004016105fc906133e8565b601054600160a01b900460ff16156108a55760405162461bcd60e51b81526004016105fc90613268565b6108ad6128c7565b6108b56119da565b90506108c081611b7e565b506108c96128c7565b50336000908152601260209081526040918290208251918201909252905481526108f16128c7565b815161090c575060408051602081019091526000815261093b565b33600090815260126020526040902060020154600d5461093790610931908590611d30565b82611d51565b9150505b6109436128c7565b61094d8287611b49565b805160405191925033917f9d624b01705090e0c402c84f2bdef9c498399a009cee9a4e08ab004bae44712191610985918b9190613518565b60405180910390a2336000908152601260205260409020815190556109a86109ef565b3360008181526012602052604090206001810192909255600d546002909201919091558551600e556109da9087611d72565b50505050505050565b60045481565b60085481565b435b90565b6010546001600160a01b03163314610a1e5760405162461bcd60e51b81526004016105fc90612e4e565b7f3a954648dc1ef6ec8f27ab3e4e360b29cabcdc89a7b6af23a7d33b186f223c5381604051610a4d9190612c9e565b60405180910390a16040805160208101909152819052601155565b610a706128c7565b600080610a8a600754610a8587600354611e3a565b611e7f565b9150610a9e600854610a8587600554611e3a565b90506000610ac3610aae83611ea4565b6040805160208101909152600c548152611eb8565b90506000610ae8610ad385611ea4565b6040805160208101909152600b548152611eb8565b90506000610b0d610af886611ea4565b60408051602081019091526009548152611eb8565b90506000610b32610b1d86611ea4565b6040805160208101909152600a548152611eb8565b90506000610b408386611ee0565b90506000610b4e8386611ee0565b905081811115610b7257610b6b610b658284611f05565b8b6118a8565b9850610b85565b6040518060200160405280600081525098505b5050505050509250925092565b610b9a6128c7565b610ba26128c7565b610c3b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663aa5af0fd6040518163ffffffff1660e01b815260040160206040518083038186803b158015610bfe57600080fd5b505afa158015610c12573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c369190612b10565b611f2d565b8051909150610c5c5760405162461bcd60e51b81526004016105fc90612de9565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636c540baf6040518163ffffffff1660e01b815260040160206040518083038186803b158015610cb757600080fd5b505afa158015610ccb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cef9190612b10565b905080610cfa6109ef565b1015610d185760405162461bcd60e51b81526004016105fc90613013565b6000610d2b610d256109ef565b83611f05565b905080610d3d578293505050506109f1565b610d456128c7565b610da17f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f8f9da286040518163ffffffff1660e01b815260040160206040518083038186803b158015610bfe57600080fd5b9050610dab6128c7565b610db58284611d30565b9050610de085610ddb836014604051806020016040529081600082015481525050611b49565b611f47565b955050505050506109f1565b6000610dfc836000015183611eb8565b90505b92915050565b610e0d6128c7565b506040805160208101909152818152610e246128da565b50336000908152601260209081526040918290208251608081018452815460608201818152825260018301549382019390935260029091015492810192909252610e805760405162461bcd60e51b81526004016105fc90612d7a565b7f00000000000000000000000000000000000000000000000000000000000000008160200151610eae6109ef565b031015610ecd5760405162461bcd60e51b81526004016105fc90612d2d565b610ed56128c7565b610edd6119da565b9050610ee76128c7565b610ef082611b7e565b9050610efa6128c7565b610f17610f0d8560000151600d54611d30565b8560400151611d51565b8551909150610f24578094505b610f2e8582611f86565b610f4a5760405162461bcd60e51b81526004016105fc90612e92565b610f526128c7565b6040805160208101909152600e548152610f6c9084611f8e565b9050610f788682611f86565b610f945760405162461bcd60e51b81526004016105fc9061336b565b6040805160208101909152600e548152610faf908790611f86565b610fcb5760405162461bcd60e51b81526004016105fc9061321d565b610fd36128c7565b610fdd8388611f8e565b805160405191925033917fda84cdf19e8ef1de60c2e7ecedcb3b440ae5dcaa1ace44fd3a9111d824356e6591611015918c9190613518565b60405180910390a26110256109ef565b336000908152601260209081526040918290206001810193909355600d546002840155835190925580519182019052600e5481526110639088611f8e565b51600e556110713388611fb3565b5050505050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b6010546001600160a01b031633146110c95760405162461bcd60e51b81526004016105fc906130e2565b7f81ff49596187b8a1171fd1c1f47390d63b10c52113fecc4a4eff1ae1feeaee7482826040516110fa929190612c15565b60405180910390a160405163a9059cbb60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906111509085908590600401612c15565b602060405180830381600087803b15801561116a57600080fd5b505af115801561117e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111a291906129a1565b505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b60075481565b600c5481565b7f000000000000000000000000000000000000000000000000000000000000000081565b6112036128c7565b61120b6128c7565b6040805160208101909152600b5481526112259086611f8e565b9050600061125c6112567f000000000000000000000000000000000000000000000000000000000000000087611e3a565b83611eb8565b905061126881856118a8565b9695505050505050565b60115481565b7f000000000000000000000000000000000000000000000000000000000000000081565b6010546001600160a01b031633146112c65760405162461bcd60e51b81526004016105fc90613164565b8082106112e55760405162461bcd60e51b81526004016105fc90613119565b7f15870c625f3ba69feb270c10e4a11ff6f6c36d08b25bf69e1efae181f337b1208282604051611316929190613518565b60405180910390a161132782611f2d565b51600c5561133481611f2d565b51600b555050565b600b5481565b600e5481565b60095481565b600a5481565b7f000000000000000000000000000000000000000000000000000000000000000081565b60055481565b600d5481565b60035481565b6113926128c7565b61139a6128c7565b6040805160208101909152600c548152611225908690611f8e565b600f5481565b6113c36128c7565b6113cb6119da565b90506113d681611b7e565b506000888888888888886040516020016113f69796959493929190612c63565b60408051601f1981840301815291815281516020928301206000818152601390935291205490915060ff1615156001146114425760405162461bcd60e51b81526004016105fc90612f66565b600061145561144f6109ef565b89611f05565b90507f00000000000000000000000000000000000000000000000000000000000000008110156114975760405162461bcd60e51b81526004016105fc9061303a565b61149f6128c7565b604080516020810190915260025481526114c1906114bc8c611f2d565b612076565b90506114cb6128c7565b5060408051602081019091528681526114e26128c7565b6114eb8a611f2d565b90506114f56128c7565b8d15611510576115098585848d878c6120a9565b9050611521565b61151e8585848d878c612208565b90505b6040516370a0823160e01b81526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906370a0823190611570903090600401612bc3565b602060405180830381600087803b15801561158a57600080fd5b505af115801561159e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115c29190612b10565b905080826000015111156115e25760405180602001604052808281525091505b600061160e877f0000000000000000000000000000000000000000000000000000000000000000611f05565b90506116186128c7565b506040805160208101909152600081527f00000000000000000000000000000000000000000000000000000000000000008211156116ff577f0000000000000000000000000000000000000000000000000000000000000000820361167b6128c7565b6116ad6116a77f0000000000000000000000000000000000000000000000000000000000000000611f2d565b83611d30565b8051601454919250106116cf57604080516020810190915260145481526116d1565b805b905060405180602001604052806116ec886000015184611eb8565b905292506116fa8684611f8e565b955050505b835181516002546040516001600160a01b038f16938d937f93eb2111fe97d82145065cf28523f16424bbf533e378b8ae2f5a63eb7bec23ec9361174193613526565b60405180910390a36000898152601360205260409020805460ff191690556117698b85611fb3565b6117733382611fb3565b5050505050505050505050505050505050565b61178e6128c7565b600061179c60045485611eb8565b905060006117ac60065486611eb8565b905060006117db876117d6600554600a604051806020016040529081600082015481525050611eb8565b611e3a565b90506000611805886117d66003546009604051806020016040529081600082015481525050611eb8565b905061180f6128c7565b61182261181c8386611ee0565b886118a8565b905061182c6128c7565b61183f6118398588611ee0565b896118a8565b6040805160208101909152600e548152909150611866906118609084611b49565b8261233d565b9a9950505050505050505050565b601054600160a01b900460ff1681565b7f000000000000000000000000000000000000000000000000000000000000000081565b6118b06128c7565b60006118bc8484612374565b6040805160208101909152908152949350505050565b601260209081526000918252604091829020825191820190925281548152600182015460029092015490919083565b6119096128c7565b60008054600f54829182916001600160a01b03909116906327fc0024908b8b6119328c8b610dec565b61193c8c8c610dec565b6040518663ffffffff1660e01b815260040161195c959493929190612ca7565b604080518083038186803b15801561197357600080fd5b505afa158015611987573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119ab9190612b28565b915091506119b882611f2d565b999098509650505050505050565b6000610dfc60018484612392565b60025481565b6119e26128c7565b611a3e7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663182df0f56040518163ffffffff1660e01b815260040160206040518083038186803b158015610bfe57600080fd5b905090565b60136020526000908152604090205460ff1681565b6000610dfc60008484612392565b6010546001600160a01b03163314611a905760405162461bcd60e51b81526004016105fc90612fcb565b6000546001600160a01b0382811691161415611abe5760405162461bcd60e51b81526004016105fc90612f94565b6000546040517faa0318754c43eb4a32620f6f8887531662fb2f7f5deb5ab2b318f63a0c9f076291611afb9184916001600160a01b031690612bd7565b60405180910390a1600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b031681565b6010546001600160a01b031681565b60065481565b611b516128c7565b6040518060200160405280611b6e85600001518560000151611ee0565b90529392505050565b5190511090565b611b866128c7565b600154611b916109ef565b1015611baf5760405162461bcd60e51b81526004016105fc9061345b565b6000600154611bbc6109ef565b039050611bc76128c7565b600080611bd48487610a68565b9250925092508360001415611bef5782945050505050611d2b565b611bf76128c7565b611bff610b92565b9050611c096128c7565b60408051602081019091526002548152611c24908390612076565b9050611c2e6128c7565b60408051602081019091526014548152611c49908390611f8e565b9050611c536128c7565b611c5e88838c611786565b600d5481519192509015611c9357611c90611c7b600d5484612687565b6040805160208101909152600e548152612697565b90505b6000611ca160045486611eb8565b90506000611cb160065487611eb8565b600889905560078a90558451600e55600d8490556004839055600681905587516002559050611cde6109ef565b60015583518a516040517f2335845cb850fcf8fbf00f6231fabd745068faf756278e33bb45716d4cf934f392611d15929091613518565b60405180910390a1509799505050505050505050505b919050565b611d386128c7565b6040518060200160405280611b6e856000015185611e3a565b611d596128c7565b6040518060200160405280611b6e8560000151856126a3565b80516040516323b872dd60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016916323b872dd91611dc3918691309190600401612bf1565b602060405180830381600087803b158015611ddd57600080fd5b505af1158015611df1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e1591906129a1565b1515600114611e365760405162461bcd60e51b81526004016105fc90612d01565b5050565b6000821580611e47575081155b15611e5457506000610dff565b82820282848281611e6157fe5b0414610dfc5760405162461bcd60e51b81526004016105fc90612f02565b600081830380841215610dfc5760405162461bcd60e51b81526004016105fc90612e20565b6000808213611eb4576000610dff565b5090565b6000670de0b6b3a7640000611ed1848460000151611e3a565b81611ed857fe5b049392505050565b600082820183811015610dfc5760405162461bcd60e51b81526004016105fc906131b0565b600082821115611f275760405162461bcd60e51b81526004016105fc9061342c565b50900390565b611f356128c7565b50604080516020810190915290815290565b611f4f6128c7565b6040518060200160405280670de0b6b3a7640000611f7586600001518660000151611e3a565b81611f7c57fe5b0490529392505050565b519051111590565b611f966128c7565b6040518060200160405280611b6e85600001518560000151611f05565b805115611e3657805160405163a9059cbb60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169163a9059cbb91612008918691600401612c15565b602060405180830381600087803b15801561202257600080fd5b505af1158015612036573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061205a91906129a1565b611e365760405162461bcd60e51b81526004016105fc906132c6565b61207e6128c7565b6040518060200160405280611b6e6120a28660000151670de0b6b3a7640000611e3a565b85516126a3565b6120b16128c7565b60006120bf600354866126cd565b905060006120d86004546120d3888b611eb8565b6126cd565b90506120e26128c7565b826120f8576120f16000611f2d565b905061213f565b6121006128c7565b6040805160208101909152600954815260035461212f9161212091611d30565b61212a8b8b611d30565b61233d565b905061213b8185611d51565b9150505b600061217a6007546121758a6117d68f7f0000000000000000000000000000000000000000000000000000000000000000611f05565b6126e8565b90506121846128c7565b61219a61181c6121948b8f611e3a565b8c611eb8565b90506121a46128c7565b6121d06118398b6121cb8f6014604051806020016040529081600082015481525050611f8e565b611eb8565b90506121e56121df8a83611b49565b8361233d565b600396909655505060049290925560079190915551600955979650505050505050565b6122106128c7565b600061221e600554866126cd565b905060006122326006546120d3888b611eb8565b905061223c6128c7565b826122525761224b6000611f2d565b905061228a565b61225a6128c7565b6040805160208101909152600a54815260055461227a9161212091611d30565b90506122868184611d51565b9150505b60006122c06008546121758a6117d68f7f0000000000000000000000000000000000000000000000000000000000000000611f05565b90506122ca6128c7565b6122da61181c6121948b8f611e3a565b90506122e46128c7565b61230b6118398b6121cb8f6014604051806020016040529081600082015481525050611f8e565b905061231a6118608a84611b49565b600596909655505060069290925560089190915551600a55979650505050505050565b6123456128c7565b82518251106123635750604080516020810190915260008152610dff565b61236d8383611f8e565b9050610dff565b6000610dfc61238b84670de0b6b3a7640000611e3a565b83516126a3565b601054600090600160a01b900460ff16156123bf5760405162461bcd60e51b81526004016105fc90613268565b7f00000000000000000000000000000000000000000000000000000000000000008310156123ff5760405162461bcd60e51b81526004016105fc906132f3565b6124076128c7565b61240f6119da565b90506124196128c7565b61242282611b7e565b905061242c6128c7565b506040805160208082018352600e5482528251908101909252601154825290612456908290611b77565b6124725760405162461bcd60e51b81526004016105fc906131db565b61247a6128c7565b60006124898989868689611901565b915091506124956128c7565b89156125135782518810156124bc5760405162461bcd60e51b81526004016105fc90613492565b6124c46128c7565b6124d8866124d3868d8b6111fb565b611b49565b90506124e48186611f86565b6125005760405162461bcd60e51b81526004016105fc906133b3565b61250b8a858961270d565b915050612582565b82518811156125345760405162461bcd60e51b81526004016105fc90613090565b61253c6128c7565b61254b866124d3868d8b61138a565b90506125578186611f86565b6125735760405162461bcd60e51b81526004016105fc906133b3565b61257e8a85896127ed565b9150505b6002548a9061258f6109ef565b855184516040516125aa95949392918f913390602001612c63565b60408051601f1981840301815291815281516020928301206000818152601390935291205490975060ff16156125f25760405162461bcd60e51b81526004016105fc90613068565b336001600160a01b0316877f9bd76dee09f83be107bfb98bb838387d6be9992388da0de713711424c3473cd68c60026000015461262d6109ef565b88600001518f886000015160405161264a96959493929190612c39565b60405180910390a36000878152601360205260409020805460ff19166001179055600f82905561267a3382611d72565b5050505050509392505050565b6000610dfc838360000151611e3a565b6000610dfc8383600001515b60008082116126c45760405162461bcd60e51b81526004016105fc90612eda565b818381611ed857fe5b60008282106126de57506000610dff565b61236d8383611f05565b600082820180841315610dfc5760405162461bcd60e51b81526004016105fc90612f39565b6127156128c7565b600061272360035486611ee0565b9050600061273360045487611ee0565b905060006127676007546121757f00000000000000000000000000000000000000000000000000000000000000008a611e3a565b90506127716128c7565b6040805160208101909152600954815260035461278e9190611d30565b90506127986128c7565b6127a2888a611d30565b90506127ac6128c7565b6127bf6127b98484611b49565b87611d51565b90506127cc898b8a61138a565b60049590955560039590955550509151600955600791909155949350505050565b6127f56128c7565b600061280360055486611ee0565b9050600061281360065487611ee0565b905060006128476008546121757f00000000000000000000000000000000000000000000000000000000000000008a611e3a565b90506128516128c7565b6040805160208101909152600a54815260055461286e9190611d30565b90506128786128c7565b612882888a611d30565b905061288c6128c7565b6128996127b98484611b49565b90506128a6898b8a6111fb565b60069590955560059590955550509151600a55600891909155949350505050565b6040518060200160405280600081525090565b60405180606001604052806128ed6128c7565b815260200160008152602001600081525090565b600060208284031215612912578081fd5b6040516020810181811067ffffffffffffffff82111715612931578283fd5b6040529135825250919050565b60006020828403121561294f578081fd5b8135610dfc8161353c565b6000806040838503121561296c578081fd5b82356129778161353c565b946020939093013593505050565b600060208284031215612996578081fd5b8135610dfc81613554565b6000602082840312156129b2578081fd5b8151610dfc81613554565b600080600080600060a086880312156129d4578081fd5b85356129df81613554565b9450602086013593506129f58760408801612901565b9250612a048760608801612901565b9150612a138760808801612901565b90509295509295909350565b600080600080600080600060e0888a031215612a39578182fd5b8735612a4481613554565b96506020880135955060408801359450606088013593506080880135925060a0880135915060c0880135612a778161353c565b8091505092959891949750929550565b600060208284031215612a98578081fd5b5035919050565b60008060408385031215612ab1578182fd5b612abb8484612901565b9150612aca8460208501612901565b90509250929050565b600080600060608486031215612ae7578283fd5b612af18585612901565b925060208401359150612b078560408601612901565b90509250925092565b600060208284031215612b21578081fd5b5051919050565b60008060408385031215612b3a578081fd5b505080516020909101519092909150565b60008060408385031215612b5d578182fd5b82359150612aca8460208501612901565b600080600060608486031215612b82578081fd5b83359250612b938560208601612901565b9150612b078560408601612901565b60008060408385031215612bb4578182fd5b50508035926020909101359150565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b03929092168252602082015260400190565b901515815260200190565b9515158652602086019490945260408501929092526060840152608083015260a082015260c00190565b9615158752602087019590955260408601939093526060850191909152608084015260a08301526001600160a01b031660c082015260e00190565b90815260200190565b948552921515602085015260408401919091526060830152608082015260a00190565b6020808252601e908201527f4d7573742062652061646d696e20746f2064656c656761746520636f6d700000604082015260600190565b602080825260129082015271151c985b9cd9995c88125b8811985a5b195960721b604082015260600190565b6020808252602d908201527f4c6971756964697479206d75737420626520737570706c6965642061206d696e60408201526c34b6bab690323ab930ba34b7b760991b606082015260800190565b60208082526021908201527f4d7573742077697468647261772066726f6d20616374697665206163636f756e6040820152601d60fa1b606082015260800190565b602080825260149082015273135d5cdd0818da185b99d9481a5cd4185d5cd95960621b604082015260600190565b60208082526017908201527f42656e63686d61726b20696e646578206973207a65726f000000000000000000604082015260600190565b602080825260149082015273696e74202d2075696e7420756e646572666c6f7760601b604082015260600190565b60208082526024908201527f4d7573742062652061646d696e20746f20736574206c6971697564697479206c6040820152631a5b5a5d60e21b606082015260800190565b60208082526028908201527f547279696e6720746f2072656d6f7665206d6f7265207468616e206163636f756040820152676e742076616c756560c01b606082015260800190565b6020808252600e908201526d646976696465206279207a65726f60901b604082015260600190565b60208082526017908201527f6d756c7469706c69636174696f6e206f766572666c6f77000000000000000000604082015260600190565b602080825260139082015272696e74202b2075696e74206f766572666c6f7760681b604082015260600190565b602080825260149082015273139bc81858dd1a5d99481cddd85c08199bdd5b9960621b604082015260600190565b60208082526017908201527f526573657474696e6720746f2073616d65206d6f64656c000000000000000000604082015260600190565b60208082526028908201527f4d7573742062652061646d696e20746f2073657420696e7465726573742072616040820152671d19481b5bd9195b60c21b606082015260800190565b6020808252600d908201526c426e2064656372656173696e6760981b604082015260600190565b60208082526014908201527305072656d617475726520636c6f736520737761760641b604082015260600190565b6020808252600e908201526d04475706c696361746520737761760941b604082015260600190565b60208082526032908201527f54686520666978656420726174652052686f20776f756c64207061792069732060408201527118995b1bddc81d5cd95c89dcc81b1a5b5a5d60721b606082015260800190565b6020808252601e908201527f4d7573742062652061646d696e20746f207472616e7366657220636f6d700000604082015260600190565b6020808252602b908201527f4d696e20666c6f61742072617465206d7573742062652062656c6f77206d617860408201526a20666c6f6174207261746560a81b606082015260800190565b6020808252602c908201527f4d7573742062652061646d696e20746f2073657420636f6c6c61746572616c2060408201526b726571756972656d656e747360a01b606082015260800190565b6020808252601190820152706164646974696f6e206f766572666c6f7760781b604082015260600190565b60208082526022908201527f4f70656e207061757365642c2061626f7665206c6971756964697479206c696d6040820152611a5d60f21b606082015260800190565b6020808252602b908201527f52656d6f76696e67206d6f7265207468616e20746f74616c20737570706c696560408201526a72206c697175696469747960a81b606082015260800190565b6020808252600d908201526c13585c9ad95d081c185d5cd959609a1b604082015260600190565b6020808252601d908201527f4d7573742062652061646d696e20746f206368616e67652061646d696e000000604082015260600190565b602080825260139082015272151c985b9cd9995c8813dd5d0819985a5b1959606a1b604082015260600190565b60208082526028908201527f53776170206e6f74696f6e616c20616d6f756e74206d75737420657863656564604082015267206d696e696d756d60c01b606082015260800190565b6020808252601690820152754d7573742062652061646d696e20746f20706175736560501b604082015260600190565b60208082526028908201527f52656d6f76696e67206d6f7265206c6971756964697479207468616e206973206040820152671d5b9b1bd8dad95960c21b606082015260800190565b6020808252818101527f496e73756666696369656e742070726f746f636f6c20636f6c6c61746572616c604082015260600190565b60208082526024908201527f537570706c79207061757365642c2061626f7665206c6971756964697479206c6040820152631a5b5a5d60e21b606082015260800190565b6020808252601590820152747375627472616374696f6e20756e646572666c6f7760581b604082015260600190565b60208082526017908201527f426c6f636b206e756d6265722064656372656173696e67000000000000000000604082015260600190565b60208082526036908201527f54686520666978656420726174652052686f20776f756c642072656365697665604082015275081a5cc818589bdd99481d5cd95c89dcc81b1a5b5a5d60521b606082015260800190565b9051815260200190565b925183526020830191909152604082015260600190565b91518252602082015260400190565b918252602082015260400190565b9283526020830191909152604082015260600190565b6001600160a01b038116811461355157600080fd5b50565b801515811461355157600080fdfea264697066735822122062f1826bc8f6923680fc82c8f7dbdb2eaafce9a7d71881478348489f6ef5a50464736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"contract CTokenInterface\",\"name\":\"cToken_\",\"type\":\"address\"},{\"internalType\":\"contract CompInterface\",\"name\":\"comp_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapMinDuration_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyMinDuration_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidityLimitCTokens_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplierLiquidityNew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedCollateralNew\",\"type\":\"uint256\"}],\"name\":\"Accrue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AdminRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexFinal\",\"type\":\"uint256\"}],\"name\":\"CloseSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"CompDelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CompTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OpenSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyValue\",\"type\":\"uint256\"}],\"name\":\"Remove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa\",\"type\":\"uint256\"}],\"name\":\"SetCollateralRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldModel\",\"type\":\"address\"}],\"name\":\"SetInterestRateModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"SetLiquidityLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"SetPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLOSE_GRACE_PERIOD_BLOCKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLOSE_PENALTY_PER_BLOCK_MANTISSA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_SWAP_NOTIONAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPPLY_MIN_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_MIN_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"_changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"_delegateComp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused_\",\"type\":\"bool\"}],\"name\":\"_pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa_\",\"type\":\"uint256\"}],\"name\":\"_setCollateralRequirements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"newModel\",\"type\":\"address\"}],\"name\":\"_setInterestRateModel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit_\",\"type\":\"uint256\"}],\"name\":\"_setLiquidityLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_transferComp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRatePaying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRateReceiving\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"benchmarkIndexStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"internalType\":\"contract CTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"comp\",\"outputs\":[{\"internalType\":\"contract CompInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBenchmarkIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExchangeRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accruedBlocks\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getLockedCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"parBlocksReceivingFixedNew\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"parBlocksPayingFixedNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"fixedRate\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getPayFixedInitCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"fixedRate\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getReceiveFixedInitCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accruedBlocks\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"floatRate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getSupplierLiquidity\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidityNew\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidity_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAccrualBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openPayFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openReceiveFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksPayingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksReceivingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateFactor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplierLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyAccounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"toCTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"toUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{\"_setInterestRateModel(address)\":{\"notice\":\"ADMIN FUNCTIONS *\"}}}},\"settings\":{\"compilationTarget\":{\"contracts/Rho.sol\":\"Rho\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Math.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\n/* @dev A safe math lib for Rho data types. \\n   Note: always returns type of left side param */\\ncontract Math is Types {\\n\\n\\tuint constant EXP_SCALE = 1e18;\\n    Exp ONE_EXP = Exp({mantissa: EXP_SCALE});\\n\\n    function _toExp(uint num) pure internal returns (Exp memory) {\\n    \\treturn Exp({mantissa: num});\\n    }\\n\\n    function _toUint(int a) pure internal returns (uint) {\\n        return a > 0 ? uint(a) : 0;\\n    }\\n\\n    function _lt(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val < b.val;\\n    }\\n\\n    function _lte(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val <= b.val;\\n    }\\n\\n    function _add(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _add(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _add(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _add(a.val, b.val)});\\n    }\\n\\n    function _add(uint a, uint b) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function _sub(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _sub(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _subToZero(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        if (b.val >= a.val) {\\n            return CTokenAmount({val: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(uint a, uint b) pure internal returns (uint) {\\n        if (b >= a) {\\n            return 0;\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        if (b.mantissa >= a.mantissa) {\\n            return Exp({mantissa: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _sub(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _sub(a.val, b.val)});\\n    }\\n\\n    function _sub(uint a, uint b) pure internal returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function _sub(int a, uint b) pure internal returns (int) {\\n        int c = a - int(b);\\n        require(a >= c, \\\"int - uint underflow\\\");\\n        return c;\\n    }\\n\\n    function _add(int a, uint b) pure internal returns (int) {\\n        int c = a + int(b);\\n        require(a <= c, \\\"int + uint overflow\\\");\\n        return c;\\n    }\\n\\n    function _mul(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _mul(a, b.val);\\n    }\\n\\n    function _mul(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _mul(a.val, b)});\\n    }\\n\\n    function _mul(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b.mantissa) / EXP_SCALE});\\n    }\\n\\n    function _mul(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b)});\\n    }\\n\\n    function _mul(uint a, Exp memory b) pure internal returns (uint) {\\n        return _mul(a, b.mantissa) / EXP_SCALE;\\n    }\\n\\n    function _mul(uint a, uint b) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function _div(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _div(a, b.val);\\n    }\\n\\n    function _div(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _div(a.val, b)});\\n    }\\n\\n    function _div(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(_mul(a.mantissa, EXP_SCALE), b.mantissa)});\\n    }\\n\\n    function _div(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(a.mantissa, b)});\\n    }\\n\\n    function _div(uint a, Exp memory b) pure internal returns (uint) {\\n        return _div(_mul(a, EXP_SCALE), b.mantissa);\\n    }\\n\\n    function _div(uint a, uint b) pure internal returns (uint) {\\n        require(b > 0, \\\"divide by zero\\\");\\n        return a / b;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x8c6200920feaf6aa32f936d0daf59a94bc84b9b5808c425db8b1eba60bd65e06\"},\"contracts/Rho.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Math.sol\\\";\\nimport {RhoInterface, CTokenInterface, CompInterface, InterestRateModelInterface} from \\\"./RhoInterfaces.sol\\\";\\n\\n/* @dev:\\n * CTokens are used as collateral. \\\"Underlying\\\" in Rho refers to the collateral CToken's underlying token.\\n * An Exp is a data type with 18 decimals, used for scaling up and precise calculations */\\ncontract Rho is RhoInterface, Math {\\n\\n\\tCTokenInterface public immutable cToken;\\n\\tCompInterface public immutable comp;\\n\\n\\tuint public immutable SWAP_MIN_DURATION;\\n\\tuint public immutable SUPPLY_MIN_DURATION;\\n\\tuint public immutable MIN_SWAP_NOTIONAL = 1e18;\\n\\tuint public immutable CLOSE_GRACE_PERIOD_BLOCKS = 3000; // ~12.5 hrs\\n\\tuint public immutable CLOSE_PENALTY_PER_BLOCK_MANTISSA = 1e14;// 1% (1e16) every 25 min (100 blocks)\\n\\n\\tconstructor (\\n\\t\\tInterestRateModelInterface interestRateModel_,\\n\\t\\tCTokenInterface cToken_,\\n\\t\\tCompInterface comp_,\\n\\t\\tuint minFloatRateMantissa_,\\n\\t\\tuint maxFloatRateMantissa_,\\n\\t\\tuint swapMinDuration_,\\n\\t\\tuint supplyMinDuration_,\\n\\t\\taddress admin_,\\n\\t\\tuint liquidityLimitCTokens_\\n\\t) public {\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\tinterestRateModel = interestRateModel_;\\n\\t\\tcToken = cToken_;\\n\\t\\tcomp = comp_;\\n\\t\\tminFloatRate = _toExp(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = _toExp(maxFloatRateMantissa_);\\n\\t\\tSWAP_MIN_DURATION = swapMinDuration_;\\n\\t\\tSUPPLY_MIN_DURATION = supplyMinDuration_;\\n\\t\\tadmin = admin_;\\n\\n\\t\\tsupplyIndex = ONE_EXP.mantissa;\\n\\t\\tbenchmarkIndexStored = _toExp(cToken_.borrowIndex());\\n\\t\\tisPaused = false;\\n\\t\\tliquidityLimit = CTokenAmount({val:liquidityLimitCTokens_});\\n\\t}\\n\\n\\t/* @dev Supplies liquidity to the protocol. Become the counterparty for all swap traders, in return for fees.\\n\\t * @param cTokenSupplyAmount Amount to supply, in CTokens.\\n\\t */\\n\\tfunction supply(uint cTokenSupplyAmount) public override {\\n\\t\\tCTokenAmount memory supplyAmount = CTokenAmount({val: cTokenSupplyAmount});\\n\\t\\tCTokenAmount memory supplierLiquidityNew = _add(supplierLiquidity, supplyAmount);\\n\\t\\t\\n\\t\\trequire(_lt(supplierLiquidityNew, liquidityLimit), \\\"Supply paused, above liquidity limit\\\");\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory prevSupply = supplyAccounts[msg.sender].amount;\\n\\n\\t\\tCTokenAmount memory truedUpPrevSupply;\\n\\t\\tif (prevSupply.val == 0) {\\n\\t\\t\\ttruedUpPrevSupply = CTokenAmount({val: 0});\\n\\t\\t} else {\\n\\t\\t\\tuint prevIndex = supplyAccounts[msg.sender].index;\\n\\t\\t\\ttruedUpPrevSupply = _div(_mul(prevSupply, supplyIndex), prevIndex);\\n\\t\\t}\\n\\n\\t\\tCTokenAmount memory newSupplyAmount = _add(truedUpPrevSupply, supplyAmount);\\n\\n\\t\\temit Supply(msg.sender, cTokenSupplyAmount, newSupplyAmount.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].amount = newSupplyAmount;\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\n\\t\\ttransferIn(msg.sender, supplyAmount);\\n\\t}\\n\\n\\t/* @dev Remove liquidity from protocol. Can only perform after a waiting period from supplying, to prevent interest rate manipulation\\n\\t * @param removeCTokenAmount Amount of CTokens to remove. 0 removes all CTokens.\\n\\t */\\n\\tfunction remove(uint removeCTokenAmount) public override {\\n\\t\\tCTokenAmount memory removeAmount = CTokenAmount({val: removeCTokenAmount});\\n\\t\\tSupplyAccount memory account = supplyAccounts[msg.sender];\\n\\t\\trequire(account.amount.val > 0, \\\"Must withdraw from active account\\\");\\n\\t\\trequire(getBlockNumber() - account.lastBlock >= SUPPLY_MIN_DURATION, \\\"Liquidity must be supplied a minimum duration\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory truedUpAccountValue = _div(_mul(account.amount, supplyIndex), account.index);\\n\\n\\t\\t// Remove all liquidity\\n\\t\\tif (removeAmount.val == 0) {\\n\\t\\t\\tremoveAmount = truedUpAccountValue;\\n\\t\\t}\\n\\t\\trequire(_lte(removeAmount, truedUpAccountValue), \\\"Trying to remove more than account value\\\");\\n\\t\\tCTokenAmount memory unlockedCollateral = _sub(supplierLiquidity, lockedCollateral);\\n\\t\\t\\n\\t\\trequire(_lte(removeAmount, unlockedCollateral), \\\"Removing more liquidity than is unlocked\\\");\\n\\t\\trequire(_lte(removeAmount, supplierLiquidity), \\\"Removing more than total supplier liquidity\\\");\\n\\n\\t\\tCTokenAmount memory newAccountValue = _sub(truedUpAccountValue, removeAmount);\\n\\n\\t\\temit Remove(msg.sender, removeCTokenAmount, newAccountValue.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\t\\tsupplyAccounts[msg.sender].amount = newAccountValue;\\n\\n\\t\\tsupplierLiquidity = _sub(supplierLiquidity, removeAmount);\\n\\n\\t\\ttransferOut(msg.sender, removeAmount);\\n\\t}\\n\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(true, notionalAmount, maximumFixedRateMantissa);\\n\\t}\\n\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(false, notionalAmount, minFixedRateMantissa);\\n\\t}\\n\\n\\t/* @dev Opens a new interest rate swap\\n\\t * @param userPayingFixed : The user can choose if they want to receive fixed or pay fixed (the protocol will take the opposite side)\\n\\t * @param notionalAmount : The principal that interest rate payments will be based on\\n\\t * @param fixedRateLimitMantissa : The maximum (if payingFixed) or minimum (if receivingFixed) rate the swap should succeed at. Prevents frontrunning attacks.\\n\\t \\t* The amount of interest to pay over 2,102,400 blocks (~1 year), with 18 decimals of precision. Eg: 5% per block-year => 0.5e18.\\n\\t*/\\n\\tfunction openInternal(bool userPayingFixed, uint notionalAmount, uint fixedRateLimitMantissa) internal returns (bytes32 swapHash) {\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\t\\trequire(notionalAmount >= MIN_SWAP_NOTIONAL, \\\"Swap notional amount must exceed minimum\\\");\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityTemp = supplierLiquidity; // copy to memory for gas\\n\\t\\trequire(_lt(supplierLiquidityTemp, liquidityLimit), \\\"Open paused, above liquidity limit\\\");\\n\\t\\t\\n\\t\\t(Exp memory swapFixedRate, int rateFactorNew) = getSwapRate(userPayingFixed, notionalAmount, lockedCollateral, supplierLiquidityTemp, cTokenExchangeRate);\\n\\t\\tCTokenAmount memory userCollateralCTokens;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\trequire(swapFixedRate.mantissa <= fixedRateLimitMantissa, \\\"The fixed rate Rho would receive is above user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = _add(lockedCollateral, getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(_lte(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openPayFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\trequire(swapFixedRate.mantissa >= fixedRateLimitMantissa, \\\"The fixed rate Rho would pay is below user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = _add(lockedCollateral, getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(_lte(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openReceiveFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t}\\n\\n\\t\\tswapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t));\\n\\n\\t\\trequire(swaps[swapHash] == false, \\\"Duplicate swap\\\");\\n\\n\\t\\temit OpenSwap(\\n\\t\\t\\tswapHash,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t);\\n\\n\\t\\tswaps[swapHash] = true;\\n\\t\\trateFactor = rateFactorNew;\\n\\t\\ttransferIn(msg.sender, userCollateralCTokens);\\n\\t}\\n\\n\\n\\t// @dev User is paying fixed, protocol is receiving fixed\\n\\tfunction openPayFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalReceivingFixedNew = _add(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = _add(notionalPayingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksReceivingFixedNew = _add(parBlocksReceivingFixed, _mul(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRateReceivingNew = (avgFixedRateReceiving * notionalReceivingFixed + notionalAmount * swapFixedRate) / (notionalReceivingFixed + notionalAmount);*/\\n\\t\\tExp memory priorFixedReceivingRate = _mul(avgFixedRateReceiving, notionalReceivingFixed);\\n\\t\\tExp memory orderFixedReceivingRate = _mul(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRateReceivingNew = _div(_add(priorFixedReceivingRate, orderFixedReceivingRate), notionalReceivingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t// @dev User is receiving fixed, protocol is paying fixed\\n\\tfunction openReceiveFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalPayingFixedNew = _add(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = _add(notionalReceivingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksPayingFixedNew = _add(parBlocksPayingFixed, _mul(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRatePayingNew = (avgFixedRatePaying * notionalPayingFixed + notionalAmount * swapFixedRate) / (notionalPayingFixed + notionalAmount) */\\n\\t\\tExp memory priorFixedPayingRate = _mul(avgFixedRatePaying, notionalPayingFixed);\\n\\t\\tExp memory orderFixedPayingRate = _mul(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRatePayingNew = _div(_add(priorFixedPayingRate, orderFixedPayingRate), notionalPayingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t/* @dev Closes an existing swap, after the min swap duration. Float payment continues even if closed late.\\n\\t * Takes params from Open event.\\n\\t * Take caution not to unecessarily revert due to underflow / overflow, as uncloseable swaps are very dangerous.\\n\\t */\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) public override {\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tbytes32 swapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexInit,\\n\\t\\t\\tinitBlock,\\n\\t\\t\\tswapFixedRateMantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens,\\n\\t\\t\\towner\\n\\t\\t));\\n\\t\\trequire(swaps[swapHash] == true, \\\"No active swap found\\\");\\n\\t\\tuint swapDuration = _sub(getBlockNumber(), initBlock);\\n\\t\\trequire(swapDuration >= SWAP_MIN_DURATION, \\\"Premature close swap\\\");\\n\\t\\tExp memory benchmarkIndexRatio = _div(benchmarkIndexStored, _toExp(benchmarkIndexInit));\\n\\n\\t\\tCTokenAmount memory userCollateral = CTokenAmount({val: userCollateralCTokens});\\n\\t\\tExp memory swapFixedRate = _toExp(swapFixedRateMantissa);\\n\\n\\t\\tCTokenAmount memory userPayout;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\tuserPayout = closePayFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tuserPayout = closeReceiveFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tuint bal = cToken.balanceOf(address(this));\\n\\n\\t\\t// Payout is capped by total balance\\n\\t\\tif (userPayout.val > bal) userPayout = CTokenAmount({val: bal});\\n\\n\\t\\tuint lateBlocks = _sub(swapDuration, SWAP_MIN_DURATION);\\n\\t\\tCTokenAmount memory penalty = CTokenAmount(0);\\n\\n\\t\\tif (lateBlocks > CLOSE_GRACE_PERIOD_BLOCKS) {\\n\\t\\t\\tuint penaltyBlocks = lateBlocks - CLOSE_GRACE_PERIOD_BLOCKS;\\n\\t\\t\\tExp memory penaltyPercent = _mul(_toExp(CLOSE_PENALTY_PER_BLOCK_MANTISSA), penaltyBlocks);\\n\\t\\t\\tpenaltyPercent = ONE_EXP.mantissa > penaltyPercent.mantissa ? penaltyPercent : ONE_EXP; // maximum of 100% penalty\\n\\t\\t\\tpenalty = CTokenAmount(_mul(userPayout.val, penaltyPercent));\\n\\t\\t\\tuserPayout = _sub(userPayout, penalty);\\n\\t\\t}\\n\\n\\t\\temit CloseSwap(swapHash, owner, userPayout.val, penalty.val, benchmarkIndexStored.mantissa);\\n\\n\\t\\tswaps[swapHash] = false;\\n\\t\\ttransferOut(owner, userPayout);\\n\\t\\ttransferOut(msg.sender, penalty);\\n\\t}\\n\\n\\t// @dev User paid fixed, protocol paid fixed\\n\\tfunction closePayFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalReceivingFixedNew = _subToZero(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = _subToZero(notionalPayingFloat, _mul(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRateReceiving = avgFixedRateReceiving * notionalReceivingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRateReceivingNew;\\n\\t\\tif (notionalReceivingFixedNew == 0){\\n\\t\\t\\tavgFixedRateReceivingNew = _toExp(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = _subToZero(_mul(avgFixedRateReceiving, notionalReceivingFixed), _mul(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRateReceivingNew = _div(numerator, notionalReceivingFixedNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksReceivingFixedNew = _add(parBlocksReceivingFixed, _mul(notionalAmount, _sub(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(_mul(_mul(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(_mul(notionalAmount, _sub(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = _subToZero(_add(userCollateral, floatLeg), fixedLeg); // no underflows\\n\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t// @dev User received fixed, protocol paid fixed\\n\\tfunction closeReceiveFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalPayingFixedNew = _subToZero(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = _subToZero(notionalReceivingFloat, _mul(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRatePaying = avgFixedRatePaying * notionalPayingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRatePayingNew;\\n\\t\\tif (notionalPayingFixedNew == 0) {\\n\\t\\t\\tavgFixedRatePayingNew = _toExp(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = _subToZero(_mul(avgFixedRatePaying, notionalPayingFixed), _mul(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRatePayingNew = _div(numerator, notionalReceivingFloatNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksPayingFixedNew = _add(parBlocksPayingFixed, _mul(notionalAmount, _sub(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(_mul(_mul(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(_mul(notionalAmount, _sub(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = _subToZero(_add(userCollateral, fixedLeg), floatLeg);\\n\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t/* @dev Called internally at the beginning of external swap and liquidity provider functions.\\n\\t * WRITES TO STORAGE\\n\\t * Accounts for interest rate payments and adjust collateral requirements with the passage of time.\\n\\t * @return lockedCollateralNew : The amount of collateral the protocol needs to keep locked.\\n\\t */\\n\\tfunction accrue(Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory) {\\n\\t\\trequire(getBlockNumber() >= lastAccrualBlock, \\\"Block number decreasing\\\");\\n\\t\\tuint accruedBlocks = getBlockNumber() - lastAccrualBlock;\\n\\t\\t(CTokenAmount memory lockedCollateralNew, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) = getLockedCollateral(accruedBlocks, cTokenExchangeRate);\\n\\n\\t\\tif (accruedBlocks == 0) {\\n\\t\\t\\treturn lockedCollateralNew;\\n\\t\\t}\\n\\n\\t\\tExp memory benchmarkIndexNew = getBenchmarkIndex();\\n\\t\\tExp memory benchmarkIndexRatio = _div(benchmarkIndexNew, benchmarkIndexStored);\\n\\t\\tExp memory floatRate = _sub(benchmarkIndexRatio, ONE_EXP);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityNew = getSupplierLiquidity(accruedBlocks, floatRate, cTokenExchangeRate);\\n\\n\\t\\t// supplyIndex *= supplierLiquidityNew / supplierLiquidity\\n\\t\\tuint supplyIndexNew = supplyIndex;\\n\\t\\tif (supplierLiquidityNew.val != 0) {\\n\\t\\t\\tsupplyIndexNew = _div(_mul(supplyIndex, supplierLiquidityNew), supplierLiquidity);\\n\\t\\t}\\n\\n\\t\\tuint notionalPayingFloatNew = _mul(notionalPayingFloat, benchmarkIndexRatio);\\n\\t\\tuint notionalReceivingFloatNew = _mul(notionalReceivingFloat, benchmarkIndexRatio);\\n\\n\\t\\t/** Apply Effects **/\\n\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\t\\tsupplyIndex = supplyIndexNew;\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\n\\t\\tbenchmarkIndexStored = benchmarkIndexNew;\\n\\t\\tlastAccrualBlock = getBlockNumber();\\n\\n\\t\\temit Accrue(supplierLiquidityNew.val, lockedCollateralNew.val);\\n\\t\\treturn lockedCollateralNew;\\n\\t}\\n\\n\\tfunction transferIn(address from, CTokenAmount memory cTokenAmount) internal {\\n\\t\\trequire(cToken.transferFrom(from, address(this), cTokenAmount.val) == true, \\\"Transfer In Failed\\\");\\n\\t}\\n\\n\\tfunction transferOut(address to, CTokenAmount memory cTokenAmount) internal {\\n\\t\\tif (cTokenAmount.val > 0) {\\n\\t\\t\\trequire(cToken.transfer(to, cTokenAmount.val), \\\"Transfer Out failed\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t// ** PUBLIC PURE HELPERS ** //\\n\\n\\tfunction toCTokens(uint amount, Exp memory cTokenExchangeRate) public pure returns (CTokenAmount memory) {\\n\\t\\tuint cTokenAmount = _div(amount, cTokenExchangeRate);\\n\\t\\treturn CTokenAmount({val: cTokenAmount});\\n\\t}\\n\\n\\tfunction toUnderlying(CTokenAmount memory amount, Exp memory cTokenExchangeRate) public pure returns (uint) {\\n\\t\\treturn _mul(amount.val, cTokenExchangeRate);\\n\\t}\\n\\n\\t// *** PUBLIC VIEW GETTERS *** //\\n\\n\\t// @dev Calculate protocol locked collateral and parBlocks, which is a measure of the fixed rate credit/debt.\\n\\t// * Uses int to keep negatives, for correct late blocks calc when a single swap is outstanding\\n\\tfunction getLockedCollateral(uint accruedBlocks, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory lockedCollateral, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) {\\n\\t\\tparBlocksReceivingFixedNew = _sub(parBlocksReceivingFixed, _mul(accruedBlocks, notionalReceivingFixed));\\n\\t\\tparBlocksPayingFixedNew = _sub(parBlocksPayingFixed, _mul(accruedBlocks, notionalPayingFixed));\\n\\n\\t\\t// Par blocks can be negative during the first or last ever swap, so floor them to 0\\n\\t\\tuint minFloatToReceive = _mul(_toUint(parBlocksPayingFixedNew), minFloatRate);\\n\\t\\tuint maxFloatToPay = _mul(_toUint(parBlocksReceivingFixedNew), maxFloatRate);\\n\\n\\t\\tuint fixedToReceive = _mul(_toUint(parBlocksReceivingFixedNew), avgFixedRateReceiving);\\n\\t\\tuint fixedToPay = _mul(_toUint(parBlocksPayingFixedNew), avgFixedRatePaying);\\n\\n\\t\\tuint minCredit = _add(fixedToReceive, minFloatToReceive);\\n\\t\\tuint maxDebt = _add(fixedToPay, maxFloatToPay);\\n\\n\\t\\tif (maxDebt > minCredit) {\\n\\t\\t\\tlockedCollateral = toCTokens(_sub(maxDebt, minCredit), cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\tlockedCollateral = CTokenAmount({val:0});\\n\\t\\t}\\n\\t}\\n\\n\\t/* @dev Calculate protocol P/L by adding the cashflows since last accrual.\\n\\t * \\t\\tsupplierLiquidity += fixedReceived + floatReceived - fixedPaid - floatPaid\\n\\t */\\n\\tfunction getSupplierLiquidity(uint accruedBlocks, Exp memory floatRate, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory supplierLiquidityNew) {\\n\\t\\tuint floatPaid = _mul(notionalPayingFloat, floatRate);\\n\\t\\tuint floatReceived = _mul(notionalReceivingFloat, floatRate);\\n\\t\\tuint fixedPaid = _mul(accruedBlocks, _mul(notionalPayingFixed, avgFixedRatePaying));\\n\\t\\tuint fixedReceived = _mul(accruedBlocks, _mul(notionalReceivingFixed, avgFixedRateReceiving));\\n\\n\\t\\tCTokenAmount memory rec = toCTokens(_add(fixedReceived, floatReceived), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory paid = toCTokens(_add(fixedPaid, floatPaid), cTokenExchangeRate);\\n\\t\\tsupplierLiquidityNew = _subToZero(_add(supplierLiquidity, rec), paid);\\n\\t}\\n\\n\\t// @dev Get the rate for incoming swaps\\n\\tfunction getSwapRate(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tCTokenAmount memory lockedCollateral,\\n\\t\\tCTokenAmount memory supplierLiquidity_,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) public view returns (Exp memory, int) {\\n\\t\\t(uint ratePerBlockMantissa, int rateFactorNew) = interestRateModel.getSwapRate(\\n\\t\\t\\trateFactor,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\torderNotional,\\n\\t\\t\\ttoUnderlying(lockedCollateral, cTokenExchangeRate),\\n\\t\\t\\ttoUnderlying(supplierLiquidity_, cTokenExchangeRate)\\n\\t\\t);\\n\\t\\treturn (_toExp(ratePerBlockMantissa), rateFactorNew);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the payFixed leg of a swap paying fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (swapFixedRate - minFloatRate)\\n\\tfunction getPayFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = _sub(fixedRate, minFloatRate);\\n\\t\\tuint amt = _mul(_mul(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the receiveFixed leg of a swap receiving fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (maxFloatRate - swapFixedRate)\\n\\tfunction getReceiveFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = _sub(maxFloatRate, fixedRate);\\n\\t\\tuint amt = _mul(_mul(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev Interpolates to get the current borrow index from a compound CToken (or some other similar interface)\\n\\tfunction getBenchmarkIndex() public view returns (Exp memory) {\\n\\t\\tExp memory borrowIndex = _toExp(cToken.borrowIndex());\\n\\t\\trequire(borrowIndex.mantissa != 0, \\\"Benchmark index is zero\\\");\\n\\t\\tuint accrualBlockNumber = cToken.accrualBlockNumber();\\n\\t\\trequire(getBlockNumber() >= accrualBlockNumber, \\\"Bn decreasing\\\");\\n\\t\\tuint blockDelta = _sub(getBlockNumber(), accrualBlockNumber);\\n\\n\\t\\tif (blockDelta == 0) {\\n\\t\\t\\treturn borrowIndex;\\n\\t\\t} else {\\n\\t\\t\\tExp memory borrowRateMantissa = _toExp(cToken.borrowRatePerBlock());\\n\\t\\t\\tExp memory simpleInterestFactor = _mul(borrowRateMantissa, blockDelta);\\n\\t\\t\\treturn _mul(borrowIndex, _add(simpleInterestFactor, ONE_EXP));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getExchangeRate() public view returns (Exp memory) {\\n\\t\\treturn _toExp(cToken.exchangeRateStored());\\n\\t}\\n\\n\\tfunction getBlockNumber() public view virtual returns (uint) {\\n\\t\\treturn block.number;\\n\\t}\\n\\n\\t/** ADMIN FUNCTIONS **/\\n\\n\\tfunction _setInterestRateModel(InterestRateModelInterface newModel) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set interest rate model\\\");\\n\\t\\trequire(newModel != interestRateModel, \\\"Resetting to same model\\\");\\n\\t\\temit SetInterestRateModel(address(newModel), address(interestRateModel));\\n\\t\\tinterestRateModel = newModel;\\n\\t}\\n\\n\\tfunction _setCollateralRequirements(uint minFloatRateMantissa_, uint maxFloatRateMantissa_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set collateral requirements\\\");\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\temit SetCollateralRequirements(minFloatRateMantissa_, maxFloatRateMantissa_);\\n\\t\\tminFloatRate = _toExp(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = _toExp(maxFloatRateMantissa_);\\n\\t}\\n\\n\\tfunction _setLiquidityLimit(uint limit_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set liqiudity limit\\\");\\n\\t\\temit SetLiquidityLimit(limit_);\\n\\t\\tliquidityLimit = CTokenAmount({val: limit_});\\n\\t}\\n\\n\\tfunction _pause(bool isPaused_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to pause\\\");\\n\\t\\trequire(isPaused_ != isPaused, \\\"Must change isPaused\\\");\\n\\t\\temit SetPause(isPaused_);\\n\\t\\tisPaused = isPaused_;\\n\\t}\\n\\n\\tfunction _transferComp(address dest, uint amount) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to transfer comp\\\");\\n\\t\\temit CompTransferred(dest, amount);\\n\\t\\tcomp.transfer(dest, amount);\\n\\t}\\n\\n\\tfunction _delegateComp(address delegatee) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to delegate comp\\\");\\n\\t\\temit CompDelegated(delegatee);\\n\\t\\tcomp.delegate(delegatee);\\n\\t}\\n\\n\\tfunction _changeAdmin(address admin_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to change admin\\\");\\n\\t\\temit AdminChanged(admin, admin_);\\n\\t\\tadmin = admin_;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xba5537c4bfd0b58acb50c9619c3eb173343af4d88ebe599094a2860ed6796aaa\"},\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"}},\"version\":1}"},"contracts/RhoInterfaces.sol:CTokenInterface":{"abi":"[{\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","bin":"","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/RhoInterfaces.sol\":\"CTokenInterface\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"}},\"version\":1}"},"contracts/RhoInterfaces.sol:CompInterface":{"abi":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","bin":"","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/RhoInterfaces.sol\":\"CompInterface\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"}},\"version\":1}"},"contracts/RhoInterfaces.sol:ERC20Interface":{"abi":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","bin":"","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/RhoInterfaces.sol\":\"ERC20Interface\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"}},\"version\":1}"},"contracts/RhoInterfaces.sol:InterestRateModelInterface":{"abi":"[{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"rateFactorPrev\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplierLiquidityUnderlying\",\"type\":\"uint256\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rateFactorNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","bin":"","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"rateFactorPrev\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplierLiquidityUnderlying\",\"type\":\"uint256\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rateFactorNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/RhoInterfaces.sol\":\"InterestRateModelInterface\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"}},\"version\":1}"},"contracts/RhoInterfaces.sol:RhoInterface":{"abi":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplierLiquidityNew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedCollateralNew\",\"type\":\"uint256\"}],\"name\":\"Accrue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AdminRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexFinal\",\"type\":\"uint256\"}],\"name\":\"CloseSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"CompDelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CompTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OpenSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyValue\",\"type\":\"uint256\"}],\"name\":\"Remove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa\",\"type\":\"uint256\"}],\"name\":\"SetCollateralRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldModel\",\"type\":\"address\"}],\"name\":\"SetInterestRateModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"SetLiquidityLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"SetPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRatePaying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRateReceiving\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"benchmarkIndexStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAccrualBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openPayFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openReceiveFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksPayingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksReceivingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateFactor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplierLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyAccounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","bin":"","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplierLiquidityNew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedCollateralNew\",\"type\":\"uint256\"}],\"name\":\"Accrue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AdminRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexFinal\",\"type\":\"uint256\"}],\"name\":\"CloseSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"CompDelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CompTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OpenSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyValue\",\"type\":\"uint256\"}],\"name\":\"Remove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa\",\"type\":\"uint256\"}],\"name\":\"SetCollateralRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldModel\",\"type\":\"address\"}],\"name\":\"SetInterestRateModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"SetLiquidityLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"SetPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRatePaying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRateReceiving\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"benchmarkIndexStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAccrualBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openPayFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openReceiveFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksPayingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksReceivingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateFactor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplierLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyAccounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/RhoInterfaces.sol\":\"RhoInterface\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"}},\"version\":1}"},"contracts/RhoLens.sol:RhoLensV1":{"abi":"[{\"inputs\":[{\"internalType\":\"contract Rho\",\"name\":\"rho_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"}],\"name\":\"getHypotheticalOrderInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"protocolIsCollateralized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarkets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalReceivingFixed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notionalPayingFixed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avgFixedRateReceiving\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avgFixedRatePaying\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupplyCollateralState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidity\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rho\",\"outputs\":[{\"internalType\":\"contract Rho\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"toCTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenAmt\",\"type\":\"uint256\"}],\"name\":\"toUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","bin":"60c0604052670de0b6b3a764000060a081905260005534801561002157600080fd5b5060405161139038038061139083398101604081905261004091610055565b60601b6001600160601b031916608052610083565b600060208284031215610066578081fd5b81516001600160a01b038116811461007c578182fd5b9392505050565b60805160601c61128c6101046000398061010c528061013a52806101ea5280610294528061032952806103ba528061044e52806104fd52806105915280610669528061074752806108075280610898528061095952806109ea5280610a795280610b365280610bcd5280610c5e5280610cef5280610d80525061128c6000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c806320aba08b146100675780635dd5df841461008557806362abe592146100a5578063908fcbd8146100bc578063eb438fc2146100df578063ec2c9016146100f2575b600080fd5b61006f61010a565b60405161007c91906110e4565b60405180910390f35b61009861009336600461108e565b61012e565b60405161007c91906111f0565b6100ad61027a565b60405161007c939291906111b1565b6100cf6100ca366004610fe3565b6106fc565b60405161007c949392919061121e565b6100986100ed36600461108e565b610a6d565b6100fa610bc5565b60405161007c949392919061123b565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000610138610f93565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e6aa216c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561019157600080fd5b505afa1580156101a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101c99190611012565b90506101d3610f93565b60405163beff7b5b60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063beff7b5b9061022190879086906004016111f9565b60206040518083038186803b15801561023957600080fd5b505afa15801561024d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102719190611012565b51949350505050565b610282610f93565b61028a610f93565b610292610f93565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e6aa216c6040518163ffffffff1660e01b815260040160206040518083038186803b1580156102eb57600080fd5b505afa1580156102ff573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103239190611012565b905060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316631f46eaae6040518163ffffffff1660e01b815260040160206040518083038186803b15801561038057600080fd5b505afa158015610394573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103b891906110a6565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166342cbb15c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561041157600080fd5b505afa158015610425573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044991906110a6565b0390507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663432ffe2782846040518363ffffffff1660e01b815260040161049a9291906111f9565b60606040518083038186803b1580156104b257600080fd5b505afa1580156104c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104ea919061102d565b509094506104f89050610f93565b61062a7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316634422581d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561055457600080fd5b505afa158015610568573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061058c9190611012565b6106257f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e5505aed6040518163ffffffff1660e01b815260040160206040518083038186803b1580156105e857600080fd5b505afa1580156105fc573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062091906110a6565b610e1d565b610e37565b9050610634610f93565b6040805160208101909152600054815261064f908390610e75565b60405163ac07293b60e01b81529091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063ac07293b906106a290869085908990600401611208565b60206040518083038186803b1580156106ba57600080fd5b505afa1580156106ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f29190611012565b9450505050909192565b60008060008061070a610f93565b610712610f93565b61071a610f93565b61072261027a565b925092509250610730610f93565b60405163cfba9e0360e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063cfba9e0390610784908d908d908990899089906004016110be565b604080518083038186803b15801561079b57600080fd5b505afa1580156107af573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d39190611062565b509050600194506107e2610f93565b6107ea610f93565b8b1561094257604051634f443fdd60e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690639e887fba906108409086908f9089906004016111d8565b60206040518083038186803b15801561085857600080fd5b505afa15801561086c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108909190611012565b915061093b867f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636c7f44da868f896040518463ffffffff1660e01b81526004016108e6939291906111d8565b60206040518083038186803b1580156108fe57600080fd5b505afa158015610912573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109369190611012565b610e9a565b9050610a3b565b60405163363fa26d60e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690636c7f44da906109929086908f9089906004016111d8565b60206040518083038186803b1580156109aa57600080fd5b505afa1580156109be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109e29190611012565b9150610a38867f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639e887fba868f896040518463ffffffff1660e01b81526004016108e6939291906111d8565b90505b805185511015610a4a57600096505b82518251610a5781610a6d565b919b509950975050505050505092959194509250565b6000610a77610f93565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e6aa216c6040518163ffffffff1660e01b815260040160206040518083038186803b158015610ad057600080fd5b505afa158015610ae4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b089190611012565b9050610b12610f93565b506040805160208101825284815290516344f94a1960e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906344f94a1990610b6d90849086906004016111c8565b60206040518083038186803b158015610b8557600080fd5b505afa158015610b99573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bbd91906110a6565b949350505050565b6000806000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166399c432ee6040518163ffffffff1660e01b815260040160206040518083038186803b158015610c2457600080fd5b505afa158015610c38573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c5c91906110a6565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166391a51a406040518163ffffffff1660e01b815260040160206040518083038186803b158015610cb557600080fd5b505afa158015610cc9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ced91906110a6565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316637fb405f06040518163ffffffff1660e01b815260040160206040518083038186803b158015610d4657600080fd5b505afa158015610d5a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d7e91906110a6565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166388369f7e6040518163ffffffff1660e01b815260040160206040518083038186803b158015610dd757600080fd5b505afa158015610deb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e0f91906110a6565b935093509350935090919293565b610e25610f93565b50604080516020810190915290815290565b610e3f610f93565b6040518060200160405280610e6a610e638660000151670de0b6b3a7640000610ebf565b8551610f14565b905290505b92915050565b610e7d610f93565b6040518060200160405280610e6a85600001518560000151610f46565b610ea2610f93565b6040518060200160405280610e6a85600001518560000151610f6e565b6000821580610ecc575081155b15610ed957506000610e6f565b82820282848281610ee657fe5b0414610f0d5760405162461bcd60e51b8152600401610f0490611120565b60405180910390fd5b9392505050565b6000808211610f355760405162461bcd60e51b8152600401610f04906110f8565b818381610f3e57fe5b049392505050565b600082821115610f685760405162461bcd60e51b8152600401610f0490611182565b50900390565b600082820183811015610f0d5760405162461bcd60e51b8152600401610f0490611157565b6040518060200160405280600081525090565b600060208284031215610fb7578081fd5b6040516020810181811067ffffffffffffffff82111715610fd6578283fd5b6040529151825250919050565b60008060408385031215610ff5578182fd5b82358015158114611004578283fd5b946020939093013593505050565b600060208284031215611023578081fd5b610f0d8383610fa6565b600080600060608486031215611041578081fd5b61104b8585610fa6565b925060208401519150604084015190509250925092565b60008060408385031215611074578182fd5b61107e8484610fa6565b9150602083015190509250929050565b60006020828403121561109f578081fd5b5035919050565b6000602082840312156110b7578081fd5b5051919050565b941515855260208501939093529051604084015251606083015251608082015260a00190565b6001600160a01b0391909116815260200190565b6020808252600e908201526d646976696465206279207a65726f60901b604082015260600190565b60208082526017908201527f6d756c7469706c69636174696f6e206f766572666c6f77000000000000000000604082015260600190565b6020808252601190820152706164646974696f6e206f766572666c6f7760781b604082015260600190565b6020808252601590820152747375627472616374696f6e20756e646572666c6f7760581b604082015260600190565b925183529051602083015251604082015260600190565b9151825251602082015260400190565b92518352602083019190915251604082015260600190565b90815260200190565b91825251602082015260400190565b9283529051602083015251604082015260600190565b938452602084019290925260408301521515606082015260800190565b9384526020840192909252604083015260608201526080019056fea26469706673582212207cb667d030757c2fce80bbe4183e30b0a2d11ab06ec11d86927a417429822b3664736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract Rho\",\"name\":\"rho_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"}],\"name\":\"getHypotheticalOrderInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"protocolIsCollateralized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarkets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalReceivingFixed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notionalPayingFixed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avgFixedRateReceiving\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avgFixedRatePaying\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupplyCollateralState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidity\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rho\",\"outputs\":[{\"internalType\":\"contract Rho\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"toCTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenAmt\",\"type\":\"uint256\"}],\"name\":\"toUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/RhoLens.sol\":\"RhoLensV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Math.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\n/* @dev A safe math lib for Rho data types. \\n   Note: always returns type of left side param */\\ncontract Math is Types {\\n\\n\\tuint constant EXP_SCALE = 1e18;\\n    Exp ONE_EXP = Exp({mantissa: EXP_SCALE});\\n\\n    function _toExp(uint num) pure internal returns (Exp memory) {\\n    \\treturn Exp({mantissa: num});\\n    }\\n\\n    function _toUint(int a) pure internal returns (uint) {\\n        return a > 0 ? uint(a) : 0;\\n    }\\n\\n    function _lt(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val < b.val;\\n    }\\n\\n    function _lte(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val <= b.val;\\n    }\\n\\n    function _add(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _add(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _add(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _add(a.val, b.val)});\\n    }\\n\\n    function _add(uint a, uint b) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function _sub(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _sub(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _subToZero(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        if (b.val >= a.val) {\\n            return CTokenAmount({val: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(uint a, uint b) pure internal returns (uint) {\\n        if (b >= a) {\\n            return 0;\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        if (b.mantissa >= a.mantissa) {\\n            return Exp({mantissa: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _sub(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _sub(a.val, b.val)});\\n    }\\n\\n    function _sub(uint a, uint b) pure internal returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function _sub(int a, uint b) pure internal returns (int) {\\n        int c = a - int(b);\\n        require(a >= c, \\\"int - uint underflow\\\");\\n        return c;\\n    }\\n\\n    function _add(int a, uint b) pure internal returns (int) {\\n        int c = a + int(b);\\n        require(a <= c, \\\"int + uint overflow\\\");\\n        return c;\\n    }\\n\\n    function _mul(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _mul(a, b.val);\\n    }\\n\\n    function _mul(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _mul(a.val, b)});\\n    }\\n\\n    function _mul(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b.mantissa) / EXP_SCALE});\\n    }\\n\\n    function _mul(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b)});\\n    }\\n\\n    function _mul(uint a, Exp memory b) pure internal returns (uint) {\\n        return _mul(a, b.mantissa) / EXP_SCALE;\\n    }\\n\\n    function _mul(uint a, uint b) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function _div(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _div(a, b.val);\\n    }\\n\\n    function _div(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _div(a.val, b)});\\n    }\\n\\n    function _div(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(_mul(a.mantissa, EXP_SCALE), b.mantissa)});\\n    }\\n\\n    function _div(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(a.mantissa, b)});\\n    }\\n\\n    function _div(uint a, Exp memory b) pure internal returns (uint) {\\n        return _div(_mul(a, EXP_SCALE), b.mantissa);\\n    }\\n\\n    function _div(uint a, uint b) pure internal returns (uint) {\\n        require(b > 0, \\\"divide by zero\\\");\\n        return a / b;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x8c6200920feaf6aa32f936d0daf59a94bc84b9b5808c425db8b1eba60bd65e06\"},\"contracts/Rho.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Math.sol\\\";\\nimport {RhoInterface, CTokenInterface, CompInterface, InterestRateModelInterface} from \\\"./RhoInterfaces.sol\\\";\\n\\n/* @dev:\\n * CTokens are used as collateral. \\\"Underlying\\\" in Rho refers to the collateral CToken's underlying token.\\n * An Exp is a data type with 18 decimals, used for scaling up and precise calculations */\\ncontract Rho is RhoInterface, Math {\\n\\n\\tCTokenInterface public immutable cToken;\\n\\tCompInterface public immutable comp;\\n\\n\\tuint public immutable SWAP_MIN_DURATION;\\n\\tuint public immutable SUPPLY_MIN_DURATION;\\n\\tuint public immutable MIN_SWAP_NOTIONAL = 1e18;\\n\\tuint public immutable CLOSE_GRACE_PERIOD_BLOCKS = 3000; // ~12.5 hrs\\n\\tuint public immutable CLOSE_PENALTY_PER_BLOCK_MANTISSA = 1e14;// 1% (1e16) every 25 min (100 blocks)\\n\\n\\tconstructor (\\n\\t\\tInterestRateModelInterface interestRateModel_,\\n\\t\\tCTokenInterface cToken_,\\n\\t\\tCompInterface comp_,\\n\\t\\tuint minFloatRateMantissa_,\\n\\t\\tuint maxFloatRateMantissa_,\\n\\t\\tuint swapMinDuration_,\\n\\t\\tuint supplyMinDuration_,\\n\\t\\taddress admin_,\\n\\t\\tuint liquidityLimitCTokens_\\n\\t) public {\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\tinterestRateModel = interestRateModel_;\\n\\t\\tcToken = cToken_;\\n\\t\\tcomp = comp_;\\n\\t\\tminFloatRate = _toExp(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = _toExp(maxFloatRateMantissa_);\\n\\t\\tSWAP_MIN_DURATION = swapMinDuration_;\\n\\t\\tSUPPLY_MIN_DURATION = supplyMinDuration_;\\n\\t\\tadmin = admin_;\\n\\n\\t\\tsupplyIndex = ONE_EXP.mantissa;\\n\\t\\tbenchmarkIndexStored = _toExp(cToken_.borrowIndex());\\n\\t\\tisPaused = false;\\n\\t\\tliquidityLimit = CTokenAmount({val:liquidityLimitCTokens_});\\n\\t}\\n\\n\\t/* @dev Supplies liquidity to the protocol. Become the counterparty for all swap traders, in return for fees.\\n\\t * @param cTokenSupplyAmount Amount to supply, in CTokens.\\n\\t */\\n\\tfunction supply(uint cTokenSupplyAmount) public override {\\n\\t\\tCTokenAmount memory supplyAmount = CTokenAmount({val: cTokenSupplyAmount});\\n\\t\\tCTokenAmount memory supplierLiquidityNew = _add(supplierLiquidity, supplyAmount);\\n\\t\\t\\n\\t\\trequire(_lt(supplierLiquidityNew, liquidityLimit), \\\"Supply paused, above liquidity limit\\\");\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory prevSupply = supplyAccounts[msg.sender].amount;\\n\\n\\t\\tCTokenAmount memory truedUpPrevSupply;\\n\\t\\tif (prevSupply.val == 0) {\\n\\t\\t\\ttruedUpPrevSupply = CTokenAmount({val: 0});\\n\\t\\t} else {\\n\\t\\t\\tuint prevIndex = supplyAccounts[msg.sender].index;\\n\\t\\t\\ttruedUpPrevSupply = _div(_mul(prevSupply, supplyIndex), prevIndex);\\n\\t\\t}\\n\\n\\t\\tCTokenAmount memory newSupplyAmount = _add(truedUpPrevSupply, supplyAmount);\\n\\n\\t\\temit Supply(msg.sender, cTokenSupplyAmount, newSupplyAmount.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].amount = newSupplyAmount;\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\n\\t\\ttransferIn(msg.sender, supplyAmount);\\n\\t}\\n\\n\\t/* @dev Remove liquidity from protocol. Can only perform after a waiting period from supplying, to prevent interest rate manipulation\\n\\t * @param removeCTokenAmount Amount of CTokens to remove. 0 removes all CTokens.\\n\\t */\\n\\tfunction remove(uint removeCTokenAmount) public override {\\n\\t\\tCTokenAmount memory removeAmount = CTokenAmount({val: removeCTokenAmount});\\n\\t\\tSupplyAccount memory account = supplyAccounts[msg.sender];\\n\\t\\trequire(account.amount.val > 0, \\\"Must withdraw from active account\\\");\\n\\t\\trequire(getBlockNumber() - account.lastBlock >= SUPPLY_MIN_DURATION, \\\"Liquidity must be supplied a minimum duration\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory truedUpAccountValue = _div(_mul(account.amount, supplyIndex), account.index);\\n\\n\\t\\t// Remove all liquidity\\n\\t\\tif (removeAmount.val == 0) {\\n\\t\\t\\tremoveAmount = truedUpAccountValue;\\n\\t\\t}\\n\\t\\trequire(_lte(removeAmount, truedUpAccountValue), \\\"Trying to remove more than account value\\\");\\n\\t\\tCTokenAmount memory unlockedCollateral = _sub(supplierLiquidity, lockedCollateral);\\n\\t\\t\\n\\t\\trequire(_lte(removeAmount, unlockedCollateral), \\\"Removing more liquidity than is unlocked\\\");\\n\\t\\trequire(_lte(removeAmount, supplierLiquidity), \\\"Removing more than total supplier liquidity\\\");\\n\\n\\t\\tCTokenAmount memory newAccountValue = _sub(truedUpAccountValue, removeAmount);\\n\\n\\t\\temit Remove(msg.sender, removeCTokenAmount, newAccountValue.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\t\\tsupplyAccounts[msg.sender].amount = newAccountValue;\\n\\n\\t\\tsupplierLiquidity = _sub(supplierLiquidity, removeAmount);\\n\\n\\t\\ttransferOut(msg.sender, removeAmount);\\n\\t}\\n\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(true, notionalAmount, maximumFixedRateMantissa);\\n\\t}\\n\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(false, notionalAmount, minFixedRateMantissa);\\n\\t}\\n\\n\\t/* @dev Opens a new interest rate swap\\n\\t * @param userPayingFixed : The user can choose if they want to receive fixed or pay fixed (the protocol will take the opposite side)\\n\\t * @param notionalAmount : The principal that interest rate payments will be based on\\n\\t * @param fixedRateLimitMantissa : The maximum (if payingFixed) or minimum (if receivingFixed) rate the swap should succeed at. Prevents frontrunning attacks.\\n\\t \\t* The amount of interest to pay over 2,102,400 blocks (~1 year), with 18 decimals of precision. Eg: 5% per block-year => 0.5e18.\\n\\t*/\\n\\tfunction openInternal(bool userPayingFixed, uint notionalAmount, uint fixedRateLimitMantissa) internal returns (bytes32 swapHash) {\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\t\\trequire(notionalAmount >= MIN_SWAP_NOTIONAL, \\\"Swap notional amount must exceed minimum\\\");\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityTemp = supplierLiquidity; // copy to memory for gas\\n\\t\\trequire(_lt(supplierLiquidityTemp, liquidityLimit), \\\"Open paused, above liquidity limit\\\");\\n\\t\\t\\n\\t\\t(Exp memory swapFixedRate, int rateFactorNew) = getSwapRate(userPayingFixed, notionalAmount, lockedCollateral, supplierLiquidityTemp, cTokenExchangeRate);\\n\\t\\tCTokenAmount memory userCollateralCTokens;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\trequire(swapFixedRate.mantissa <= fixedRateLimitMantissa, \\\"The fixed rate Rho would receive is above user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = _add(lockedCollateral, getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(_lte(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openPayFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\trequire(swapFixedRate.mantissa >= fixedRateLimitMantissa, \\\"The fixed rate Rho would pay is below user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = _add(lockedCollateral, getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(_lte(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openReceiveFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t}\\n\\n\\t\\tswapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t));\\n\\n\\t\\trequire(swaps[swapHash] == false, \\\"Duplicate swap\\\");\\n\\n\\t\\temit OpenSwap(\\n\\t\\t\\tswapHash,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t);\\n\\n\\t\\tswaps[swapHash] = true;\\n\\t\\trateFactor = rateFactorNew;\\n\\t\\ttransferIn(msg.sender, userCollateralCTokens);\\n\\t}\\n\\n\\n\\t// @dev User is paying fixed, protocol is receiving fixed\\n\\tfunction openPayFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalReceivingFixedNew = _add(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = _add(notionalPayingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksReceivingFixedNew = _add(parBlocksReceivingFixed, _mul(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRateReceivingNew = (avgFixedRateReceiving * notionalReceivingFixed + notionalAmount * swapFixedRate) / (notionalReceivingFixed + notionalAmount);*/\\n\\t\\tExp memory priorFixedReceivingRate = _mul(avgFixedRateReceiving, notionalReceivingFixed);\\n\\t\\tExp memory orderFixedReceivingRate = _mul(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRateReceivingNew = _div(_add(priorFixedReceivingRate, orderFixedReceivingRate), notionalReceivingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t// @dev User is receiving fixed, protocol is paying fixed\\n\\tfunction openReceiveFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalPayingFixedNew = _add(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = _add(notionalReceivingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksPayingFixedNew = _add(parBlocksPayingFixed, _mul(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRatePayingNew = (avgFixedRatePaying * notionalPayingFixed + notionalAmount * swapFixedRate) / (notionalPayingFixed + notionalAmount) */\\n\\t\\tExp memory priorFixedPayingRate = _mul(avgFixedRatePaying, notionalPayingFixed);\\n\\t\\tExp memory orderFixedPayingRate = _mul(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRatePayingNew = _div(_add(priorFixedPayingRate, orderFixedPayingRate), notionalPayingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t/* @dev Closes an existing swap, after the min swap duration. Float payment continues even if closed late.\\n\\t * Takes params from Open event.\\n\\t * Take caution not to unecessarily revert due to underflow / overflow, as uncloseable swaps are very dangerous.\\n\\t */\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) public override {\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tbytes32 swapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexInit,\\n\\t\\t\\tinitBlock,\\n\\t\\t\\tswapFixedRateMantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens,\\n\\t\\t\\towner\\n\\t\\t));\\n\\t\\trequire(swaps[swapHash] == true, \\\"No active swap found\\\");\\n\\t\\tuint swapDuration = _sub(getBlockNumber(), initBlock);\\n\\t\\trequire(swapDuration >= SWAP_MIN_DURATION, \\\"Premature close swap\\\");\\n\\t\\tExp memory benchmarkIndexRatio = _div(benchmarkIndexStored, _toExp(benchmarkIndexInit));\\n\\n\\t\\tCTokenAmount memory userCollateral = CTokenAmount({val: userCollateralCTokens});\\n\\t\\tExp memory swapFixedRate = _toExp(swapFixedRateMantissa);\\n\\n\\t\\tCTokenAmount memory userPayout;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\tuserPayout = closePayFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tuserPayout = closeReceiveFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tuint bal = cToken.balanceOf(address(this));\\n\\n\\t\\t// Payout is capped by total balance\\n\\t\\tif (userPayout.val > bal) userPayout = CTokenAmount({val: bal});\\n\\n\\t\\tuint lateBlocks = _sub(swapDuration, SWAP_MIN_DURATION);\\n\\t\\tCTokenAmount memory penalty = CTokenAmount(0);\\n\\n\\t\\tif (lateBlocks > CLOSE_GRACE_PERIOD_BLOCKS) {\\n\\t\\t\\tuint penaltyBlocks = lateBlocks - CLOSE_GRACE_PERIOD_BLOCKS;\\n\\t\\t\\tExp memory penaltyPercent = _mul(_toExp(CLOSE_PENALTY_PER_BLOCK_MANTISSA), penaltyBlocks);\\n\\t\\t\\tpenaltyPercent = ONE_EXP.mantissa > penaltyPercent.mantissa ? penaltyPercent : ONE_EXP; // maximum of 100% penalty\\n\\t\\t\\tpenalty = CTokenAmount(_mul(userPayout.val, penaltyPercent));\\n\\t\\t\\tuserPayout = _sub(userPayout, penalty);\\n\\t\\t}\\n\\n\\t\\temit CloseSwap(swapHash, owner, userPayout.val, penalty.val, benchmarkIndexStored.mantissa);\\n\\n\\t\\tswaps[swapHash] = false;\\n\\t\\ttransferOut(owner, userPayout);\\n\\t\\ttransferOut(msg.sender, penalty);\\n\\t}\\n\\n\\t// @dev User paid fixed, protocol paid fixed\\n\\tfunction closePayFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalReceivingFixedNew = _subToZero(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = _subToZero(notionalPayingFloat, _mul(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRateReceiving = avgFixedRateReceiving * notionalReceivingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRateReceivingNew;\\n\\t\\tif (notionalReceivingFixedNew == 0){\\n\\t\\t\\tavgFixedRateReceivingNew = _toExp(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = _subToZero(_mul(avgFixedRateReceiving, notionalReceivingFixed), _mul(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRateReceivingNew = _div(numerator, notionalReceivingFixedNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksReceivingFixedNew = _add(parBlocksReceivingFixed, _mul(notionalAmount, _sub(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(_mul(_mul(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(_mul(notionalAmount, _sub(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = _subToZero(_add(userCollateral, floatLeg), fixedLeg); // no underflows\\n\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t// @dev User received fixed, protocol paid fixed\\n\\tfunction closeReceiveFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalPayingFixedNew = _subToZero(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = _subToZero(notionalReceivingFloat, _mul(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRatePaying = avgFixedRatePaying * notionalPayingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRatePayingNew;\\n\\t\\tif (notionalPayingFixedNew == 0) {\\n\\t\\t\\tavgFixedRatePayingNew = _toExp(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = _subToZero(_mul(avgFixedRatePaying, notionalPayingFixed), _mul(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRatePayingNew = _div(numerator, notionalReceivingFloatNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksPayingFixedNew = _add(parBlocksPayingFixed, _mul(notionalAmount, _sub(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(_mul(_mul(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(_mul(notionalAmount, _sub(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = _subToZero(_add(userCollateral, fixedLeg), floatLeg);\\n\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t/* @dev Called internally at the beginning of external swap and liquidity provider functions.\\n\\t * WRITES TO STORAGE\\n\\t * Accounts for interest rate payments and adjust collateral requirements with the passage of time.\\n\\t * @return lockedCollateralNew : The amount of collateral the protocol needs to keep locked.\\n\\t */\\n\\tfunction accrue(Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory) {\\n\\t\\trequire(getBlockNumber() >= lastAccrualBlock, \\\"Block number decreasing\\\");\\n\\t\\tuint accruedBlocks = getBlockNumber() - lastAccrualBlock;\\n\\t\\t(CTokenAmount memory lockedCollateralNew, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) = getLockedCollateral(accruedBlocks, cTokenExchangeRate);\\n\\n\\t\\tif (accruedBlocks == 0) {\\n\\t\\t\\treturn lockedCollateralNew;\\n\\t\\t}\\n\\n\\t\\tExp memory benchmarkIndexNew = getBenchmarkIndex();\\n\\t\\tExp memory benchmarkIndexRatio = _div(benchmarkIndexNew, benchmarkIndexStored);\\n\\t\\tExp memory floatRate = _sub(benchmarkIndexRatio, ONE_EXP);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityNew = getSupplierLiquidity(accruedBlocks, floatRate, cTokenExchangeRate);\\n\\n\\t\\t// supplyIndex *= supplierLiquidityNew / supplierLiquidity\\n\\t\\tuint supplyIndexNew = supplyIndex;\\n\\t\\tif (supplierLiquidityNew.val != 0) {\\n\\t\\t\\tsupplyIndexNew = _div(_mul(supplyIndex, supplierLiquidityNew), supplierLiquidity);\\n\\t\\t}\\n\\n\\t\\tuint notionalPayingFloatNew = _mul(notionalPayingFloat, benchmarkIndexRatio);\\n\\t\\tuint notionalReceivingFloatNew = _mul(notionalReceivingFloat, benchmarkIndexRatio);\\n\\n\\t\\t/** Apply Effects **/\\n\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\t\\tsupplyIndex = supplyIndexNew;\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\n\\t\\tbenchmarkIndexStored = benchmarkIndexNew;\\n\\t\\tlastAccrualBlock = getBlockNumber();\\n\\n\\t\\temit Accrue(supplierLiquidityNew.val, lockedCollateralNew.val);\\n\\t\\treturn lockedCollateralNew;\\n\\t}\\n\\n\\tfunction transferIn(address from, CTokenAmount memory cTokenAmount) internal {\\n\\t\\trequire(cToken.transferFrom(from, address(this), cTokenAmount.val) == true, \\\"Transfer In Failed\\\");\\n\\t}\\n\\n\\tfunction transferOut(address to, CTokenAmount memory cTokenAmount) internal {\\n\\t\\tif (cTokenAmount.val > 0) {\\n\\t\\t\\trequire(cToken.transfer(to, cTokenAmount.val), \\\"Transfer Out failed\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t// ** PUBLIC PURE HELPERS ** //\\n\\n\\tfunction toCTokens(uint amount, Exp memory cTokenExchangeRate) public pure returns (CTokenAmount memory) {\\n\\t\\tuint cTokenAmount = _div(amount, cTokenExchangeRate);\\n\\t\\treturn CTokenAmount({val: cTokenAmount});\\n\\t}\\n\\n\\tfunction toUnderlying(CTokenAmount memory amount, Exp memory cTokenExchangeRate) public pure returns (uint) {\\n\\t\\treturn _mul(amount.val, cTokenExchangeRate);\\n\\t}\\n\\n\\t// *** PUBLIC VIEW GETTERS *** //\\n\\n\\t// @dev Calculate protocol locked collateral and parBlocks, which is a measure of the fixed rate credit/debt.\\n\\t// * Uses int to keep negatives, for correct late blocks calc when a single swap is outstanding\\n\\tfunction getLockedCollateral(uint accruedBlocks, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory lockedCollateral, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) {\\n\\t\\tparBlocksReceivingFixedNew = _sub(parBlocksReceivingFixed, _mul(accruedBlocks, notionalReceivingFixed));\\n\\t\\tparBlocksPayingFixedNew = _sub(parBlocksPayingFixed, _mul(accruedBlocks, notionalPayingFixed));\\n\\n\\t\\t// Par blocks can be negative during the first or last ever swap, so floor them to 0\\n\\t\\tuint minFloatToReceive = _mul(_toUint(parBlocksPayingFixedNew), minFloatRate);\\n\\t\\tuint maxFloatToPay = _mul(_toUint(parBlocksReceivingFixedNew), maxFloatRate);\\n\\n\\t\\tuint fixedToReceive = _mul(_toUint(parBlocksReceivingFixedNew), avgFixedRateReceiving);\\n\\t\\tuint fixedToPay = _mul(_toUint(parBlocksPayingFixedNew), avgFixedRatePaying);\\n\\n\\t\\tuint minCredit = _add(fixedToReceive, minFloatToReceive);\\n\\t\\tuint maxDebt = _add(fixedToPay, maxFloatToPay);\\n\\n\\t\\tif (maxDebt > minCredit) {\\n\\t\\t\\tlockedCollateral = toCTokens(_sub(maxDebt, minCredit), cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\tlockedCollateral = CTokenAmount({val:0});\\n\\t\\t}\\n\\t}\\n\\n\\t/* @dev Calculate protocol P/L by adding the cashflows since last accrual.\\n\\t * \\t\\tsupplierLiquidity += fixedReceived + floatReceived - fixedPaid - floatPaid\\n\\t */\\n\\tfunction getSupplierLiquidity(uint accruedBlocks, Exp memory floatRate, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory supplierLiquidityNew) {\\n\\t\\tuint floatPaid = _mul(notionalPayingFloat, floatRate);\\n\\t\\tuint floatReceived = _mul(notionalReceivingFloat, floatRate);\\n\\t\\tuint fixedPaid = _mul(accruedBlocks, _mul(notionalPayingFixed, avgFixedRatePaying));\\n\\t\\tuint fixedReceived = _mul(accruedBlocks, _mul(notionalReceivingFixed, avgFixedRateReceiving));\\n\\n\\t\\tCTokenAmount memory rec = toCTokens(_add(fixedReceived, floatReceived), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory paid = toCTokens(_add(fixedPaid, floatPaid), cTokenExchangeRate);\\n\\t\\tsupplierLiquidityNew = _subToZero(_add(supplierLiquidity, rec), paid);\\n\\t}\\n\\n\\t// @dev Get the rate for incoming swaps\\n\\tfunction getSwapRate(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tCTokenAmount memory lockedCollateral,\\n\\t\\tCTokenAmount memory supplierLiquidity_,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) public view returns (Exp memory, int) {\\n\\t\\t(uint ratePerBlockMantissa, int rateFactorNew) = interestRateModel.getSwapRate(\\n\\t\\t\\trateFactor,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\torderNotional,\\n\\t\\t\\ttoUnderlying(lockedCollateral, cTokenExchangeRate),\\n\\t\\t\\ttoUnderlying(supplierLiquidity_, cTokenExchangeRate)\\n\\t\\t);\\n\\t\\treturn (_toExp(ratePerBlockMantissa), rateFactorNew);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the payFixed leg of a swap paying fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (swapFixedRate - minFloatRate)\\n\\tfunction getPayFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = _sub(fixedRate, minFloatRate);\\n\\t\\tuint amt = _mul(_mul(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the receiveFixed leg of a swap receiving fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (maxFloatRate - swapFixedRate)\\n\\tfunction getReceiveFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = _sub(maxFloatRate, fixedRate);\\n\\t\\tuint amt = _mul(_mul(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev Interpolates to get the current borrow index from a compound CToken (or some other similar interface)\\n\\tfunction getBenchmarkIndex() public view returns (Exp memory) {\\n\\t\\tExp memory borrowIndex = _toExp(cToken.borrowIndex());\\n\\t\\trequire(borrowIndex.mantissa != 0, \\\"Benchmark index is zero\\\");\\n\\t\\tuint accrualBlockNumber = cToken.accrualBlockNumber();\\n\\t\\trequire(getBlockNumber() >= accrualBlockNumber, \\\"Bn decreasing\\\");\\n\\t\\tuint blockDelta = _sub(getBlockNumber(), accrualBlockNumber);\\n\\n\\t\\tif (blockDelta == 0) {\\n\\t\\t\\treturn borrowIndex;\\n\\t\\t} else {\\n\\t\\t\\tExp memory borrowRateMantissa = _toExp(cToken.borrowRatePerBlock());\\n\\t\\t\\tExp memory simpleInterestFactor = _mul(borrowRateMantissa, blockDelta);\\n\\t\\t\\treturn _mul(borrowIndex, _add(simpleInterestFactor, ONE_EXP));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getExchangeRate() public view returns (Exp memory) {\\n\\t\\treturn _toExp(cToken.exchangeRateStored());\\n\\t}\\n\\n\\tfunction getBlockNumber() public view virtual returns (uint) {\\n\\t\\treturn block.number;\\n\\t}\\n\\n\\t/** ADMIN FUNCTIONS **/\\n\\n\\tfunction _setInterestRateModel(InterestRateModelInterface newModel) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set interest rate model\\\");\\n\\t\\trequire(newModel != interestRateModel, \\\"Resetting to same model\\\");\\n\\t\\temit SetInterestRateModel(address(newModel), address(interestRateModel));\\n\\t\\tinterestRateModel = newModel;\\n\\t}\\n\\n\\tfunction _setCollateralRequirements(uint minFloatRateMantissa_, uint maxFloatRateMantissa_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set collateral requirements\\\");\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\temit SetCollateralRequirements(minFloatRateMantissa_, maxFloatRateMantissa_);\\n\\t\\tminFloatRate = _toExp(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = _toExp(maxFloatRateMantissa_);\\n\\t}\\n\\n\\tfunction _setLiquidityLimit(uint limit_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set liqiudity limit\\\");\\n\\t\\temit SetLiquidityLimit(limit_);\\n\\t\\tliquidityLimit = CTokenAmount({val: limit_});\\n\\t}\\n\\n\\tfunction _pause(bool isPaused_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to pause\\\");\\n\\t\\trequire(isPaused_ != isPaused, \\\"Must change isPaused\\\");\\n\\t\\temit SetPause(isPaused_);\\n\\t\\tisPaused = isPaused_;\\n\\t}\\n\\n\\tfunction _transferComp(address dest, uint amount) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to transfer comp\\\");\\n\\t\\temit CompTransferred(dest, amount);\\n\\t\\tcomp.transfer(dest, amount);\\n\\t}\\n\\n\\tfunction _delegateComp(address delegatee) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to delegate comp\\\");\\n\\t\\temit CompDelegated(delegatee);\\n\\t\\tcomp.delegate(delegatee);\\n\\t}\\n\\n\\tfunction _changeAdmin(address admin_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to change admin\\\");\\n\\t\\temit AdminChanged(admin, admin_);\\n\\t\\tadmin = admin_;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xba5537c4bfd0b58acb50c9619c3eb173343af4d88ebe599094a2860ed6796aaa\"},\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/RhoLens.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Rho.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\n/* @dev A utility view contract for front-ends to use. Not part of the protocol. */\\ncontract RhoLensV1 is Math {\\n\\n\\tRho public immutable rho;\\n\\n\\tconstructor(Rho rho_) public {\\n\\t\\trho = rho_;\\n\\t}\\n\\n\\tfunction getHypotheticalOrderInfo(bool userPayingFixed, uint notionalAmount) \\n\\t\\texternal \\n\\t\\tview \\n\\t\\treturns (\\n\\t\\t\\tuint swapFixedRateMantissa, \\n\\t\\t\\tuint userCollateralCTokens, \\n\\t\\t\\tuint userCollateralUnderlying, \\n\\t\\t\\tbool protocolIsCollateralized\\n\\t\\t)\\n\\t{\\n\\t\\t(CTokenAmount memory lockedCollateral, CTokenAmount memory supplierLiquidity, Exp memory cTokenExchangeRate) = getSupplyCollateralState();\\n\\t\\t(Exp memory swapFixedRate,) = rho.getSwapRate(userPayingFixed, notionalAmount, lockedCollateral, supplierLiquidity, cTokenExchangeRate);\\n\\t\\tprotocolIsCollateralized = true;\\n\\t\\tCTokenAmount memory userCollateral;\\n\\t\\tCTokenAmount memory lockedCollateralHypothetical;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\tuserCollateral = rho.getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\t\\t\\tlockedCollateralHypothetical = _add(lockedCollateral, rho.getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t} else {\\n\\t\\t\\tuserCollateral = rho.getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\t\\t\\tlockedCollateralHypothetical = _add(lockedCollateral, rho.getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t}\\n\\t\\tif (supplierLiquidity.val < lockedCollateralHypothetical.val) {\\n\\t\\t\\tprotocolIsCollateralized = false;\\n\\t\\t}\\n\\t\\treturn (swapFixedRate.mantissa, userCollateral.val, toUnderlying(userCollateral.val), protocolIsCollateralized);\\n\\t}\\n\\n\\tfunction getSupplyCollateralState() \\n\\t\\tpublic \\n\\t\\tview \\n\\t\\treturns (\\n\\t\\t\\tCTokenAmount memory lockedCollateral, \\n\\t\\t\\tCTokenAmount memory supplierLiquidity, \\n\\t\\t\\tExp memory cTokenExchangeRate\\n\\t\\t) \\n\\t{\\n\\t\\tcTokenExchangeRate = rho.getExchangeRate();\\n\\n\\t\\tuint accruedBlocks = rho.getBlockNumber() - rho.lastAccrualBlock();\\n\\t\\t(lockedCollateral,,) = rho.getLockedCollateral(accruedBlocks, cTokenExchangeRate);\\n\\n\\t\\tExp memory benchmarkIndexRatio = _div(rho.getBenchmarkIndex(), _toExp(rho.benchmarkIndexStored()));\\n\\t\\tExp memory floatRate = _sub(benchmarkIndexRatio, ONE_EXP);\\n\\n\\t\\tsupplierLiquidity = rho.getSupplierLiquidity(accruedBlocks, floatRate, cTokenExchangeRate);\\n\\t}\\n\\n\\tfunction getMarkets() \\n\\t\\tpublic \\n\\t\\tview \\n\\t\\treturns (\\n\\t\\t\\tuint notionalReceivingFixed,\\n\\t\\t\\tuint notionalPayingFixed,\\n\\t\\t\\tuint avgFixedRateReceiving,\\n\\t\\t\\tuint avgFixedRatePaying\\n\\t\\t) \\n\\t{\\n\\t\\treturn (rho.notionalReceivingFixed(), rho.notionalPayingFixed(), rho.avgFixedRateReceiving(), rho.avgFixedRatePaying());\\n\\t}\\n\\n\\tfunction toUnderlying(uint cTokenAmt) public view returns (uint underlyingAmount) {\\n\\t\\tExp memory rate = rho.getExchangeRate();\\n\\t\\tCTokenAmount memory amount = CTokenAmount({val: cTokenAmt});\\n\\t\\treturn rho.toUnderlying(amount, rate);\\n\\t}\\n\\n\\tfunction toCTokens(uint underlyingAmount) public view returns (uint cTokenAmount) {\\n\\t\\tExp memory rate = rho.getExchangeRate();\\n\\t\\tCTokenAmount memory amount = rho.toCTokens(underlyingAmount, rate);\\n\\t\\treturn amount.val;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xf09fd0941d7f1b7d5428339c7b24d7afecae37af59bba48f580555f6bea086ac\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"}},\"version\":1}"},"contracts/Types.sol:Types":{"abi":"[]","bin":"6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea26469706673582212207517808e5264091434aac2158393800e82a1a7fdf70ce9b80db280c38e99cc8564736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/Types.sol\":\"Types\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"}},\"version\":1}"},"contracts/test/FaucetToken.sol:FaucetToken":{"abi":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimalUnits\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"allocateTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","bin":"60806040523480156200001157600080fd5b5060405162000e4038038062000e40833981810160405260808110156200003757600080fd5b8151602083018051604051929492938301929190846401000000008211156200005f57600080fd5b9083019060208201858111156200007557600080fd5b82516401000000008111828201881017156200009057600080fd5b82525081516020918201929091019080838360005b83811015620000bf578181015183820152602001620000a5565b50505050905090810190601f168015620000ed5780820380516001836020036101000a031916815260200191505b506040818152602083015192018051929491939192846401000000008211156200011657600080fd5b9083019060208201858111156200012c57600080fd5b82516401000000008111828201881017156200014757600080fd5b82525081516020918201929091019080838360005b83811015620001765781810151838201526020016200015c565b50505050905090810190601f168015620001a45780820380516001836020036101000a031916815260200191505b506040908152600188905533600090815260208181529190208890558651620001d794506003935090870191506200020c565b508051620001ed9060049060208401906200020c565b50506005805460ff191660ff9290921691909117905550620002b19050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106200024f57805160ff19168380011785556200027f565b828001600101855582156200027f579182015b828111156200027f57825182559160200191906001019062000262565b506200028d92915062000291565b5090565b620002ae91905b808211156200028d576000815560010162000298565b90565b610b7f80620002c16000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c80636618846311610071578063661884631461021257806370a082311461023e57806395d89b4114610264578063a9059cbb1461026c578063d73dd62314610298578063dd62ed3e146102c4576100b4565b806306fdde03146100b957806308bca56614610136578063095ea7b31461016457806318160ddd146101a457806323b872dd146101be578063313ce567146101f4575b600080fd5b6100c16102f2565b6040805160208082528351818301528351919283929083019185019080838360005b838110156100fb5781810151838201526020016100e3565b50505050905090810190601f1680156101285780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6101626004803603604081101561014c57600080fd5b506001600160a01b038135169060200135610380565b005b6101906004803603604081101561017a57600080fd5b506001600160a01b0381351690602001356103de565b604080519115158252519081900360200190f35b6101ac610444565b60408051918252519081900360200190f35b610190600480360360608110156101d457600080fd5b506001600160a01b0381358116916020810135909116906040013561044a565b6101fc61066b565b6040805160ff9092168252519081900360200190f35b6101906004803603604081101561022857600080fd5b506001600160a01b038135169060200135610674565b6101ac6004803603602081101561025457600080fd5b50356001600160a01b0316610764565b6100c161077f565b6101906004803603604081101561028257600080fd5b506001600160a01b0381351690602001356107da565b610190600480360360408110156102ae57600080fd5b506001600160a01b038135169060200135610901565b6101ac600480360360408110156102da57600080fd5b506001600160a01b038135811691602001351661099a565b6003805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156103785780601f1061034d57610100808354040283529160200191610378565b820191906000526020600020905b81548152906001019060200180831161035b57829003601f168201915b505050505081565b6001600160a01b0382166000818152602081815260409182902080548501905560018054850190558151848152915130927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92908290030190a35050565b3360008181526002602090815260408083206001600160a01b038716808552908352818420869055815186815291519394909390927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a350600192915050565b60015490565b60006001600160a01b0383166104915760405162461bcd60e51b8152600401808060200182810382526028815260200180610b226028913960400191505060405180910390fd5b6001600160a01b0384166000908152602081905260409020548211156104fe576040805162461bcd60e51b815260206004820181905260248201527f5472616e7366657246726f6d3a20496e61646571756174652062616c616e6365604482015290519081900360640190fd5b6001600160a01b03841660009081526002602090815260408083203384529091529020548211156105605760405162461bcd60e51b8152600401808060200182810382526022815260200180610b006022913960400191505060405180910390fd5b6001600160a01b038416600090815260208190526040902054610589908363ffffffff6109c516565b6001600160a01b0380861660009081526020819052604080822093909355908516815220546105be908363ffffffff610a0e16565b6001600160a01b03808516600090815260208181526040808320949094559187168152600282528281203382529091522054610600908363ffffffff6109c516565b6001600160a01b03808616600081815260026020908152604080832033845282529182902094909455805186815290519287169391927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef929181900390910190a35060019392505050565b60055460ff1681565b3360009081526002602090815260408083206001600160a01b0386168452909152812054808311156106c9573360009081526002602090815260408083206001600160a01b03881684529091528120556106fe565b6106d9818463ffffffff6109c516565b3360009081526002602090815260408083206001600160a01b03891684529091529020555b3360008181526002602090815260408083206001600160a01b0389168085529083529281902054815190815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a35060019392505050565b6001600160a01b031660009081526020819052604090205490565b6004805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156103785780601f1061034d57610100808354040283529160200191610378565b60006001600160a01b0383166107ef57600080fd5b33600090815260208190526040902054821115610853576040805162461bcd60e51b815260206004820152601e60248201527f5472616e736665723a20696e73756666696369656e742062616c616e63650000604482015290519081900360640190fd5b33600090815260208190526040902054610873908363ffffffff6109c516565b33600090815260208190526040808220929092556001600160a01b038516815220546108a5908363ffffffff610a0e16565b6001600160a01b038416600081815260208181526040918290209390935580518581529051919233927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a350600192915050565b3360009081526002602090815260408083206001600160a01b0386168452909152812054610935908363ffffffff610a0e16565b3360008181526002602090815260408083206001600160a01b0389168085529083529281902085905580519485525191937f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929081900390910190a350600192915050565b6001600160a01b03918216600090815260026020908152604080832093909416825291909152205490565b6000610a0783836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250610a68565b9392505050565b600082820183811015610a07576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b60008184841115610af75760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015610abc578181015183820152602001610aa4565b50505050905090810190601f168015610ae95780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b50505090039056fe5472616e7366657246726f6d3a20496e616465717561746520616c6c6f77616e63655472616e7366657246726f6d3a2043616e27742073656e6420746f2061646472657373207a65726fa26469706673582212205fbc810967e2d56b3a1659e90ab49a2c49d0e2bbc2ce5a54c4aaa8491b024de264736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimalUnits\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"allocateTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{\"allowance(address,address)\":{\"details\":\"Function to check the amount of tokens that an owner allowed to a spender.\",\"params\":{\"_owner\":\"address The address which owns the funds.\",\"_spender\":\"address The address which will spend the funds.\"},\"returns\":{\"_0\":\"A uint256 specifying the amount of tokens still available for the spender.\"}},\"approve(address,uint256)\":{\"details\":\"Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\",\"params\":{\"_spender\":\"The address which will spend the funds.\",\"_value\":\"The amount of tokens to be spent.\"}},\"balanceOf(address)\":{\"details\":\"Gets the balance of the specified address.\",\"params\":{\"_owner\":\"The address to query the the balance of.\"},\"returns\":{\"_0\":\"An uint256 representing the amount owned by the passed address.\"}},\"decreaseApproval(address,uint256)\":{\"details\":\"Decrease the amount of tokens that an owner allowed to a spender. approve should be called when allowed[_spender] == 0. To decrement allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined) From MonolithDAO Token.sol\",\"params\":{\"_spender\":\"The address which will spend the funds.\",\"_subtractedValue\":\"The amount of tokens to decrease the allowance by.\"}},\"increaseApproval(address,uint256)\":{\"details\":\"Increase the amount of tokens that an owner allowed to a spender. approve should be called when allowed[_spender] == 0. To increment allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined) From MonolithDAO Token.sol\",\"params\":{\"_addedValue\":\"The amount of tokens to increase the allowance by.\",\"_spender\":\"The address which will spend the funds.\"}},\"totalSupply()\":{\"details\":\"Total number of tokens in existence\"},\"transfer(address,uint256)\":{\"details\":\"Transfer token for a specified address\",\"params\":{\"_to\":\"The address to transfer to.\",\"_value\":\"The amount to be transferred.\"}},\"transferFrom(address,address,uint256)\":{\"details\":\"Transfer tokens from one address to another\",\"params\":{\"_from\":\"address The address which you want to send tokens from\",\"_to\":\"address The address which you want to transfer to\",\"_value\":\"uint256 the amount of tokens to be transferred\"}}}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/test/FaucetToken.sol\":\"FaucetToken\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/test/FaucetToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StandardToken.sol\\\";\\n\\ncontract FaucetToken is StandardToken {\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\\n        totalSupply_ = _initialAmount;\\n        balances[msg.sender] = _initialAmount;\\n        name = _tokenName;\\n        symbol = _tokenSymbol;\\n        decimals = _decimalUnits;\\n    }\\n\\n    function allocateTo(address _owner, uint256 value) public {\\n        balances[_owner] += value;\\n        totalSupply_ += value;\\n        emit Transfer(address(this), _owner, value);\\n    }\\n}\\n\",\"keccak256\":\"0xf4ea18824410d4a0b355ab4a738ca788384aea817c38bef9610353d277aa1804\"},\"contracts/test/SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xabba6407e3cc0e14aa98d71eac7c59513b9b68b4ac734293ac2dbab9d5cb3dfb\"},\"contracts/test/StandardToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\nabstract contract ERC20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n    function balanceOf(address who) public view virtual returns (uint256);\\n    function transfer(address to, uint256 value) public virtual returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) balances;\\n\\n    uint256 totalSupply_;\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() public view override returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        require(_to != address(0));\\n        require(_value <= balances[msg.sender], \\\"Transfer: insufficient balance\\\");\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param _owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address _owner) public view override returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n}\\n\\n\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\nabstract contract ERC20 is ERC20Basic {\\n    function allowance(address owner, address spender) public view virtual returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\\n    function approve(address spender, uint256 value) public virtual returns (bool);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/issues/20\\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n    mapping (address => mapping (address => uint256)) internal allowed;\\n\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(_to != address(0), \\\"TransferFrom: Can't send to address zero\\\");\\n        require(_value <= balances[_from], \\\"TransferFrom: Inadequate balance\\\");\\n        require(_value <= allowed[_from][msg.sender], \\\"TransferFrom: Inadequate allowance\\\");\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param _spender The address which will spend the funds.\\n     * @param _value The amount of tokens to be spent.\\n     */\\n    function approve(address _spender, uint256 _value) public override returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n     )\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (\\n            allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue > oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x33a81ce8e70f59fe7a0d01872dc70e6c46fe7b90dd983c960f074ee907feb93e\"}},\"version\":1}"},"contracts/test/MockCToken.sol:MockCToken":{"abi":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_borrowRatePerBlockMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimalUnits\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"advanceBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"allocateTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bn\",\"type\":\"uint256\"}],\"name\":\"setAccrualBlockNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowIndex_\",\"type\":\"uint256\"}],\"name\":\"setBorrowIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","bin":"6080604052670de0b6b3a764000060065560646007553480156200002257600080fd5b5060405162000fa438038062000fa4833981810160405260c08110156200004857600080fd5b8151602083015160408085015160608601805192519496939591949391820192846401000000008211156200007c57600080fd5b9083019060208201858111156200009257600080fd5b8251640100000000811182820188101715620000ad57600080fd5b82525081516020918201929091019080838360005b83811015620000dc578181015183820152602001620000c2565b50505050905090810190601f1680156200010a5780820380516001836020036101000a031916815260200191505b506040818152602083015192018051929491939192846401000000008211156200013357600080fd5b9083019060208201858111156200014957600080fd5b82516401000000008111828201881017156200016457600080fd5b82525081516020918201929091019080838360005b838110156200019357818101518382015260200162000179565b50505050905090810190601f168015620001c15780820380516001836020036101000a031916815260200191505b5060409081526001889055336000908152602081815291902088905586518894508793508692508591620001fb9160039186019062000246565b5080516200021190600490602084019062000246565b50506005805460ff191660ff92909216919091179055505050600893909355505050670de0b6b3a764000002600955620002eb565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106200028957805160ff1916838001178555620002b9565b82800160010185558215620002b9579182015b82811115620002b95782518255916020019190600101906200029c565b50620002c7929150620002cb565b5090565b620002e891905b80821115620002c75760008155600101620002d2565b90565b610ca980620002fb6000396000f3fe608060405234801561001057600080fd5b506004361061012c5760003560e01c80636c540baf116100ad578063aa5af0fd11610071578063aa5af0fd14610362578063c5a6c9431461036a578063d73dd62314610387578063dd62ed3e146103b3578063f8f9da28146103e15761012c565b80636c540baf146102e35780636c979157146102eb57806370a082311461030857806395d89b411461032e578063a9059cbb146103365761012c565b806323b872dd116100f457806323b872dd1461023e578063313ce5671461027457806337d9bd92146102925780633ba0b9a9146102af57806366188463146102b75761012c565b806306fdde031461013157806308bca566146101ae578063095ea7b3146101dc57806318160ddd1461021c578063182df0f514610236575b600080fd5b6101396103e9565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561017357818101518382015260200161015b565b50505050905090810190601f1680156101a05780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6101da600480360360408110156101c457600080fd5b506001600160a01b038135169060200135610477565b005b610208600480360360408110156101f257600080fd5b506001600160a01b0381351690602001356104d5565b604080519115158252519081900360200190f35b61022461053b565b60408051918252519081900360200190f35b610224610541565b6102086004803603606081101561025457600080fd5b506001600160a01b03813581169160208101359091169060400135610547565b61027c610768565b6040805160ff9092168252519081900360200190f35b6101da600480360360208110156102a857600080fd5b5035610771565b610224610776565b610208600480360360408110156102cd57600080fd5b506001600160a01b03813516906020013561077c565b61022461086c565b6101da6004803603602081101561030157600080fd5b5035610872565b6102246004803603602081101561031e57600080fd5b50356001600160a01b031661087d565b610139610898565b6102086004803603604081101561034c57600080fd5b506001600160a01b0381351690602001356108f3565b610224610a1a565b6101da6004803603602081101561038057600080fd5b5035610a20565b6102086004803603604081101561039d57600080fd5b506001600160a01b038135169060200135610a25565b610224600480360360408110156103c957600080fd5b506001600160a01b0381358116916020013516610abe565b610224610ae9565b6003805460408051602060026001851615610100026000190190941693909304601f8101849004840282018401909252818152929183018282801561046f5780601f106104445761010080835404028352916020019161046f565b820191906000526020600020905b81548152906001019060200180831161045257829003601f168201915b505050505081565b6001600160a01b0382166000818152602081815260409182902080548501905560018054850190558151848152915130927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92908290030190a35050565b3360008181526002602090815260408083206001600160a01b038716808552908352818420869055815186815291519394909390927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a350600192915050565b60015490565b60095490565b60006001600160a01b03831661058e5760405162461bcd60e51b8152600401808060200182810382526028815260200180610c4c6028913960400191505060405180910390fd5b6001600160a01b0384166000908152602081905260409020548211156105fb576040805162461bcd60e51b815260206004820181905260248201527f5472616e7366657246726f6d3a20496e61646571756174652062616c616e6365604482015290519081900360640190fd5b6001600160a01b038416600090815260026020908152604080832033845290915290205482111561065d5760405162461bcd60e51b8152600401808060200182810382526022815260200180610c2a6022913960400191505060405180910390fd5b6001600160a01b038416600090815260208190526040902054610686908363ffffffff610aef16565b6001600160a01b0380861660009081526020819052604080822093909355908516815220546106bb908363ffffffff610b3816565b6001600160a01b038085166000908152602081815260408083209490945591871681526002825282812033825290915220546106fd908363ffffffff610aef16565b6001600160a01b03808616600081815260026020908152604080832033845282529182902094909455805186815290519287169391927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef929181900390910190a35060019392505050565b60055460ff1681565b600655565b60095481565b3360009081526002602090815260408083206001600160a01b0386168452909152812054808311156107d1573360009081526002602090815260408083206001600160a01b0388168452909152812055610806565b6107e1818463ffffffff610aef16565b3360009081526002602090815260408083206001600160a01b03891684529091529020555b3360008181526002602090815260408083206001600160a01b0389168085529083529281902054815190815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a35060019392505050565b60075481565b600780549091019055565b6001600160a01b031660009081526020819052604090205490565b6004805460408051602060026001851615610100026000190190941693909304601f8101849004840282018401909252818152929183018282801561046f5780601f106104445761010080835404028352916020019161046f565b60006001600160a01b03831661090857600080fd5b3360009081526020819052604090205482111561096c576040805162461bcd60e51b815260206004820152601e60248201527f5472616e736665723a20696e73756666696369656e742062616c616e63650000604482015290519081900360640190fd5b3360009081526020819052604090205461098c908363ffffffff610aef16565b33600090815260208190526040808220929092556001600160a01b038516815220546109be908363ffffffff610b3816565b6001600160a01b038416600081815260208181526040918290209390935580518581529051919233927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a350600192915050565b60065481565b600755565b3360009081526002602090815260408083206001600160a01b0386168452909152812054610a59908363ffffffff610b3816565b3360008181526002602090815260408083206001600160a01b0389168085529083529281902085905580519485525191937f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929081900390910190a350600192915050565b6001600160a01b03918216600090815260026020908152604080832093909416825291909152205490565b60085481565b6000610b3183836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250610b92565b9392505050565b600082820183811015610b31576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b60008184841115610c215760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015610be6578181015183820152602001610bce565b50505050905090810190601f168015610c135780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b50505090039056fe5472616e7366657246726f6d3a20496e616465717561746520616c6c6f77616e63655472616e7366657246726f6d3a2043616e27742073656e6420746f2061646472657373207a65726fa26469706673582212200cd8f2f325bca78e3fe42a6cd2f3e97d1e2308260329ef7a5b431c383870ee7264736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_borrowRatePerBlockMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimalUnits\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"advanceBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"allocateTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bn\",\"type\":\"uint256\"}],\"name\":\"setAccrualBlockNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowIndex_\",\"type\":\"uint256\"}],\"name\":\"setBorrowIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{\"allowance(address,address)\":{\"details\":\"Function to check the amount of tokens that an owner allowed to a spender.\",\"params\":{\"_owner\":\"address The address which owns the funds.\",\"_spender\":\"address The address which will spend the funds.\"},\"returns\":{\"_0\":\"A uint256 specifying the amount of tokens still available for the spender.\"}},\"approve(address,uint256)\":{\"details\":\"Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\",\"params\":{\"_spender\":\"The address which will spend the funds.\",\"_value\":\"The amount of tokens to be spent.\"}},\"balanceOf(address)\":{\"details\":\"Gets the balance of the specified address.\",\"params\":{\"_owner\":\"The address to query the the balance of.\"},\"returns\":{\"_0\":\"An uint256 representing the amount owned by the passed address.\"}},\"decreaseApproval(address,uint256)\":{\"details\":\"Decrease the amount of tokens that an owner allowed to a spender. approve should be called when allowed[_spender] == 0. To decrement allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined) From MonolithDAO Token.sol\",\"params\":{\"_spender\":\"The address which will spend the funds.\",\"_subtractedValue\":\"The amount of tokens to decrease the allowance by.\"}},\"increaseApproval(address,uint256)\":{\"details\":\"Increase the amount of tokens that an owner allowed to a spender. approve should be called when allowed[_spender] == 0. To increment allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined) From MonolithDAO Token.sol\",\"params\":{\"_addedValue\":\"The amount of tokens to increase the allowance by.\",\"_spender\":\"The address which will spend the funds.\"}},\"totalSupply()\":{\"details\":\"Total number of tokens in existence\"},\"transfer(address,uint256)\":{\"details\":\"Transfer token for a specified address\",\"params\":{\"_to\":\"The address to transfer to.\",\"_value\":\"The amount to be transferred.\"}},\"transferFrom(address,address,uint256)\":{\"details\":\"Transfer tokens from one address to another\",\"params\":{\"_from\":\"address The address which you want to send tokens from\",\"_to\":\"address The address which you want to transfer to\",\"_value\":\"uint256 the amount of tokens to be transferred\"}}}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/test/MockCToken.sol\":\"MockCToken\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Math.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\n/* @dev A safe math lib for Rho data types. \\n   Note: always returns type of left side param */\\ncontract Math is Types {\\n\\n\\tuint constant EXP_SCALE = 1e18;\\n    Exp ONE_EXP = Exp({mantissa: EXP_SCALE});\\n\\n    function _toExp(uint num) pure internal returns (Exp memory) {\\n    \\treturn Exp({mantissa: num});\\n    }\\n\\n    function _toUint(int a) pure internal returns (uint) {\\n        return a > 0 ? uint(a) : 0;\\n    }\\n\\n    function _lt(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val < b.val;\\n    }\\n\\n    function _lte(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val <= b.val;\\n    }\\n\\n    function _add(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _add(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _add(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _add(a.val, b.val)});\\n    }\\n\\n    function _add(uint a, uint b) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function _sub(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _sub(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _subToZero(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        if (b.val >= a.val) {\\n            return CTokenAmount({val: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(uint a, uint b) pure internal returns (uint) {\\n        if (b >= a) {\\n            return 0;\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        if (b.mantissa >= a.mantissa) {\\n            return Exp({mantissa: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _sub(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _sub(a.val, b.val)});\\n    }\\n\\n    function _sub(uint a, uint b) pure internal returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function _sub(int a, uint b) pure internal returns (int) {\\n        int c = a - int(b);\\n        require(a >= c, \\\"int - uint underflow\\\");\\n        return c;\\n    }\\n\\n    function _add(int a, uint b) pure internal returns (int) {\\n        int c = a + int(b);\\n        require(a <= c, \\\"int + uint overflow\\\");\\n        return c;\\n    }\\n\\n    function _mul(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _mul(a, b.val);\\n    }\\n\\n    function _mul(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _mul(a.val, b)});\\n    }\\n\\n    function _mul(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b.mantissa) / EXP_SCALE});\\n    }\\n\\n    function _mul(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b)});\\n    }\\n\\n    function _mul(uint a, Exp memory b) pure internal returns (uint) {\\n        return _mul(a, b.mantissa) / EXP_SCALE;\\n    }\\n\\n    function _mul(uint a, uint b) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function _div(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _div(a, b.val);\\n    }\\n\\n    function _div(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _div(a.val, b)});\\n    }\\n\\n    function _div(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(_mul(a.mantissa, EXP_SCALE), b.mantissa)});\\n    }\\n\\n    function _div(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(a.mantissa, b)});\\n    }\\n\\n    function _div(uint a, Exp memory b) pure internal returns (uint) {\\n        return _div(_mul(a, EXP_SCALE), b.mantissa);\\n    }\\n\\n    function _div(uint a, uint b) pure internal returns (uint) {\\n        require(b > 0, \\\"divide by zero\\\");\\n        return a / b;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x8c6200920feaf6aa32f936d0daf59a94bc84b9b5808c425db8b1eba60bd65e06\"},\"contracts/Rho.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Math.sol\\\";\\nimport {RhoInterface, CTokenInterface, CompInterface, InterestRateModelInterface} from \\\"./RhoInterfaces.sol\\\";\\n\\n/* @dev:\\n * CTokens are used as collateral. \\\"Underlying\\\" in Rho refers to the collateral CToken's underlying token.\\n * An Exp is a data type with 18 decimals, used for scaling up and precise calculations */\\ncontract Rho is RhoInterface, Math {\\n\\n\\tCTokenInterface public immutable cToken;\\n\\tCompInterface public immutable comp;\\n\\n\\tuint public immutable SWAP_MIN_DURATION;\\n\\tuint public immutable SUPPLY_MIN_DURATION;\\n\\tuint public immutable MIN_SWAP_NOTIONAL = 1e18;\\n\\tuint public immutable CLOSE_GRACE_PERIOD_BLOCKS = 3000; // ~12.5 hrs\\n\\tuint public immutable CLOSE_PENALTY_PER_BLOCK_MANTISSA = 1e14;// 1% (1e16) every 25 min (100 blocks)\\n\\n\\tconstructor (\\n\\t\\tInterestRateModelInterface interestRateModel_,\\n\\t\\tCTokenInterface cToken_,\\n\\t\\tCompInterface comp_,\\n\\t\\tuint minFloatRateMantissa_,\\n\\t\\tuint maxFloatRateMantissa_,\\n\\t\\tuint swapMinDuration_,\\n\\t\\tuint supplyMinDuration_,\\n\\t\\taddress admin_,\\n\\t\\tuint liquidityLimitCTokens_\\n\\t) public {\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\tinterestRateModel = interestRateModel_;\\n\\t\\tcToken = cToken_;\\n\\t\\tcomp = comp_;\\n\\t\\tminFloatRate = _toExp(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = _toExp(maxFloatRateMantissa_);\\n\\t\\tSWAP_MIN_DURATION = swapMinDuration_;\\n\\t\\tSUPPLY_MIN_DURATION = supplyMinDuration_;\\n\\t\\tadmin = admin_;\\n\\n\\t\\tsupplyIndex = ONE_EXP.mantissa;\\n\\t\\tbenchmarkIndexStored = _toExp(cToken_.borrowIndex());\\n\\t\\tisPaused = false;\\n\\t\\tliquidityLimit = CTokenAmount({val:liquidityLimitCTokens_});\\n\\t}\\n\\n\\t/* @dev Supplies liquidity to the protocol. Become the counterparty for all swap traders, in return for fees.\\n\\t * @param cTokenSupplyAmount Amount to supply, in CTokens.\\n\\t */\\n\\tfunction supply(uint cTokenSupplyAmount) public override {\\n\\t\\tCTokenAmount memory supplyAmount = CTokenAmount({val: cTokenSupplyAmount});\\n\\t\\tCTokenAmount memory supplierLiquidityNew = _add(supplierLiquidity, supplyAmount);\\n\\t\\t\\n\\t\\trequire(_lt(supplierLiquidityNew, liquidityLimit), \\\"Supply paused, above liquidity limit\\\");\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory prevSupply = supplyAccounts[msg.sender].amount;\\n\\n\\t\\tCTokenAmount memory truedUpPrevSupply;\\n\\t\\tif (prevSupply.val == 0) {\\n\\t\\t\\ttruedUpPrevSupply = CTokenAmount({val: 0});\\n\\t\\t} else {\\n\\t\\t\\tuint prevIndex = supplyAccounts[msg.sender].index;\\n\\t\\t\\ttruedUpPrevSupply = _div(_mul(prevSupply, supplyIndex), prevIndex);\\n\\t\\t}\\n\\n\\t\\tCTokenAmount memory newSupplyAmount = _add(truedUpPrevSupply, supplyAmount);\\n\\n\\t\\temit Supply(msg.sender, cTokenSupplyAmount, newSupplyAmount.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].amount = newSupplyAmount;\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\n\\t\\ttransferIn(msg.sender, supplyAmount);\\n\\t}\\n\\n\\t/* @dev Remove liquidity from protocol. Can only perform after a waiting period from supplying, to prevent interest rate manipulation\\n\\t * @param removeCTokenAmount Amount of CTokens to remove. 0 removes all CTokens.\\n\\t */\\n\\tfunction remove(uint removeCTokenAmount) public override {\\n\\t\\tCTokenAmount memory removeAmount = CTokenAmount({val: removeCTokenAmount});\\n\\t\\tSupplyAccount memory account = supplyAccounts[msg.sender];\\n\\t\\trequire(account.amount.val > 0, \\\"Must withdraw from active account\\\");\\n\\t\\trequire(getBlockNumber() - account.lastBlock >= SUPPLY_MIN_DURATION, \\\"Liquidity must be supplied a minimum duration\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory truedUpAccountValue = _div(_mul(account.amount, supplyIndex), account.index);\\n\\n\\t\\t// Remove all liquidity\\n\\t\\tif (removeAmount.val == 0) {\\n\\t\\t\\tremoveAmount = truedUpAccountValue;\\n\\t\\t}\\n\\t\\trequire(_lte(removeAmount, truedUpAccountValue), \\\"Trying to remove more than account value\\\");\\n\\t\\tCTokenAmount memory unlockedCollateral = _sub(supplierLiquidity, lockedCollateral);\\n\\t\\t\\n\\t\\trequire(_lte(removeAmount, unlockedCollateral), \\\"Removing more liquidity than is unlocked\\\");\\n\\t\\trequire(_lte(removeAmount, supplierLiquidity), \\\"Removing more than total supplier liquidity\\\");\\n\\n\\t\\tCTokenAmount memory newAccountValue = _sub(truedUpAccountValue, removeAmount);\\n\\n\\t\\temit Remove(msg.sender, removeCTokenAmount, newAccountValue.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\t\\tsupplyAccounts[msg.sender].amount = newAccountValue;\\n\\n\\t\\tsupplierLiquidity = _sub(supplierLiquidity, removeAmount);\\n\\n\\t\\ttransferOut(msg.sender, removeAmount);\\n\\t}\\n\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(true, notionalAmount, maximumFixedRateMantissa);\\n\\t}\\n\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(false, notionalAmount, minFixedRateMantissa);\\n\\t}\\n\\n\\t/* @dev Opens a new interest rate swap\\n\\t * @param userPayingFixed : The user can choose if they want to receive fixed or pay fixed (the protocol will take the opposite side)\\n\\t * @param notionalAmount : The principal that interest rate payments will be based on\\n\\t * @param fixedRateLimitMantissa : The maximum (if payingFixed) or minimum (if receivingFixed) rate the swap should succeed at. Prevents frontrunning attacks.\\n\\t \\t* The amount of interest to pay over 2,102,400 blocks (~1 year), with 18 decimals of precision. Eg: 5% per block-year => 0.5e18.\\n\\t*/\\n\\tfunction openInternal(bool userPayingFixed, uint notionalAmount, uint fixedRateLimitMantissa) internal returns (bytes32 swapHash) {\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\t\\trequire(notionalAmount >= MIN_SWAP_NOTIONAL, \\\"Swap notional amount must exceed minimum\\\");\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityTemp = supplierLiquidity; // copy to memory for gas\\n\\t\\trequire(_lt(supplierLiquidityTemp, liquidityLimit), \\\"Open paused, above liquidity limit\\\");\\n\\t\\t\\n\\t\\t(Exp memory swapFixedRate, int rateFactorNew) = getSwapRate(userPayingFixed, notionalAmount, lockedCollateral, supplierLiquidityTemp, cTokenExchangeRate);\\n\\t\\tCTokenAmount memory userCollateralCTokens;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\trequire(swapFixedRate.mantissa <= fixedRateLimitMantissa, \\\"The fixed rate Rho would receive is above user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = _add(lockedCollateral, getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(_lte(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openPayFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\trequire(swapFixedRate.mantissa >= fixedRateLimitMantissa, \\\"The fixed rate Rho would pay is below user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = _add(lockedCollateral, getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(_lte(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openReceiveFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t}\\n\\n\\t\\tswapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t));\\n\\n\\t\\trequire(swaps[swapHash] == false, \\\"Duplicate swap\\\");\\n\\n\\t\\temit OpenSwap(\\n\\t\\t\\tswapHash,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t);\\n\\n\\t\\tswaps[swapHash] = true;\\n\\t\\trateFactor = rateFactorNew;\\n\\t\\ttransferIn(msg.sender, userCollateralCTokens);\\n\\t}\\n\\n\\n\\t// @dev User is paying fixed, protocol is receiving fixed\\n\\tfunction openPayFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalReceivingFixedNew = _add(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = _add(notionalPayingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksReceivingFixedNew = _add(parBlocksReceivingFixed, _mul(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRateReceivingNew = (avgFixedRateReceiving * notionalReceivingFixed + notionalAmount * swapFixedRate) / (notionalReceivingFixed + notionalAmount);*/\\n\\t\\tExp memory priorFixedReceivingRate = _mul(avgFixedRateReceiving, notionalReceivingFixed);\\n\\t\\tExp memory orderFixedReceivingRate = _mul(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRateReceivingNew = _div(_add(priorFixedReceivingRate, orderFixedReceivingRate), notionalReceivingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t// @dev User is receiving fixed, protocol is paying fixed\\n\\tfunction openReceiveFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalPayingFixedNew = _add(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = _add(notionalReceivingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksPayingFixedNew = _add(parBlocksPayingFixed, _mul(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRatePayingNew = (avgFixedRatePaying * notionalPayingFixed + notionalAmount * swapFixedRate) / (notionalPayingFixed + notionalAmount) */\\n\\t\\tExp memory priorFixedPayingRate = _mul(avgFixedRatePaying, notionalPayingFixed);\\n\\t\\tExp memory orderFixedPayingRate = _mul(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRatePayingNew = _div(_add(priorFixedPayingRate, orderFixedPayingRate), notionalPayingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t/* @dev Closes an existing swap, after the min swap duration. Float payment continues even if closed late.\\n\\t * Takes params from Open event.\\n\\t * Take caution not to unecessarily revert due to underflow / overflow, as uncloseable swaps are very dangerous.\\n\\t */\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) public override {\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tbytes32 swapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexInit,\\n\\t\\t\\tinitBlock,\\n\\t\\t\\tswapFixedRateMantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens,\\n\\t\\t\\towner\\n\\t\\t));\\n\\t\\trequire(swaps[swapHash] == true, \\\"No active swap found\\\");\\n\\t\\tuint swapDuration = _sub(getBlockNumber(), initBlock);\\n\\t\\trequire(swapDuration >= SWAP_MIN_DURATION, \\\"Premature close swap\\\");\\n\\t\\tExp memory benchmarkIndexRatio = _div(benchmarkIndexStored, _toExp(benchmarkIndexInit));\\n\\n\\t\\tCTokenAmount memory userCollateral = CTokenAmount({val: userCollateralCTokens});\\n\\t\\tExp memory swapFixedRate = _toExp(swapFixedRateMantissa);\\n\\n\\t\\tCTokenAmount memory userPayout;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\tuserPayout = closePayFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tuserPayout = closeReceiveFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tuint bal = cToken.balanceOf(address(this));\\n\\n\\t\\t// Payout is capped by total balance\\n\\t\\tif (userPayout.val > bal) userPayout = CTokenAmount({val: bal});\\n\\n\\t\\tuint lateBlocks = _sub(swapDuration, SWAP_MIN_DURATION);\\n\\t\\tCTokenAmount memory penalty = CTokenAmount(0);\\n\\n\\t\\tif (lateBlocks > CLOSE_GRACE_PERIOD_BLOCKS) {\\n\\t\\t\\tuint penaltyBlocks = lateBlocks - CLOSE_GRACE_PERIOD_BLOCKS;\\n\\t\\t\\tExp memory penaltyPercent = _mul(_toExp(CLOSE_PENALTY_PER_BLOCK_MANTISSA), penaltyBlocks);\\n\\t\\t\\tpenaltyPercent = ONE_EXP.mantissa > penaltyPercent.mantissa ? penaltyPercent : ONE_EXP; // maximum of 100% penalty\\n\\t\\t\\tpenalty = CTokenAmount(_mul(userPayout.val, penaltyPercent));\\n\\t\\t\\tuserPayout = _sub(userPayout, penalty);\\n\\t\\t}\\n\\n\\t\\temit CloseSwap(swapHash, owner, userPayout.val, penalty.val, benchmarkIndexStored.mantissa);\\n\\n\\t\\tswaps[swapHash] = false;\\n\\t\\ttransferOut(owner, userPayout);\\n\\t\\ttransferOut(msg.sender, penalty);\\n\\t}\\n\\n\\t// @dev User paid fixed, protocol paid fixed\\n\\tfunction closePayFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalReceivingFixedNew = _subToZero(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = _subToZero(notionalPayingFloat, _mul(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRateReceiving = avgFixedRateReceiving * notionalReceivingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRateReceivingNew;\\n\\t\\tif (notionalReceivingFixedNew == 0){\\n\\t\\t\\tavgFixedRateReceivingNew = _toExp(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = _subToZero(_mul(avgFixedRateReceiving, notionalReceivingFixed), _mul(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRateReceivingNew = _div(numerator, notionalReceivingFixedNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksReceivingFixedNew = _add(parBlocksReceivingFixed, _mul(notionalAmount, _sub(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(_mul(_mul(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(_mul(notionalAmount, _sub(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = _subToZero(_add(userCollateral, floatLeg), fixedLeg); // no underflows\\n\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t// @dev User received fixed, protocol paid fixed\\n\\tfunction closeReceiveFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalPayingFixedNew = _subToZero(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = _subToZero(notionalReceivingFloat, _mul(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRatePaying = avgFixedRatePaying * notionalPayingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRatePayingNew;\\n\\t\\tif (notionalPayingFixedNew == 0) {\\n\\t\\t\\tavgFixedRatePayingNew = _toExp(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = _subToZero(_mul(avgFixedRatePaying, notionalPayingFixed), _mul(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRatePayingNew = _div(numerator, notionalReceivingFloatNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksPayingFixedNew = _add(parBlocksPayingFixed, _mul(notionalAmount, _sub(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(_mul(_mul(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(_mul(notionalAmount, _sub(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = _subToZero(_add(userCollateral, fixedLeg), floatLeg);\\n\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t/* @dev Called internally at the beginning of external swap and liquidity provider functions.\\n\\t * WRITES TO STORAGE\\n\\t * Accounts for interest rate payments and adjust collateral requirements with the passage of time.\\n\\t * @return lockedCollateralNew : The amount of collateral the protocol needs to keep locked.\\n\\t */\\n\\tfunction accrue(Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory) {\\n\\t\\trequire(getBlockNumber() >= lastAccrualBlock, \\\"Block number decreasing\\\");\\n\\t\\tuint accruedBlocks = getBlockNumber() - lastAccrualBlock;\\n\\t\\t(CTokenAmount memory lockedCollateralNew, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) = getLockedCollateral(accruedBlocks, cTokenExchangeRate);\\n\\n\\t\\tif (accruedBlocks == 0) {\\n\\t\\t\\treturn lockedCollateralNew;\\n\\t\\t}\\n\\n\\t\\tExp memory benchmarkIndexNew = getBenchmarkIndex();\\n\\t\\tExp memory benchmarkIndexRatio = _div(benchmarkIndexNew, benchmarkIndexStored);\\n\\t\\tExp memory floatRate = _sub(benchmarkIndexRatio, ONE_EXP);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityNew = getSupplierLiquidity(accruedBlocks, floatRate, cTokenExchangeRate);\\n\\n\\t\\t// supplyIndex *= supplierLiquidityNew / supplierLiquidity\\n\\t\\tuint supplyIndexNew = supplyIndex;\\n\\t\\tif (supplierLiquidityNew.val != 0) {\\n\\t\\t\\tsupplyIndexNew = _div(_mul(supplyIndex, supplierLiquidityNew), supplierLiquidity);\\n\\t\\t}\\n\\n\\t\\tuint notionalPayingFloatNew = _mul(notionalPayingFloat, benchmarkIndexRatio);\\n\\t\\tuint notionalReceivingFloatNew = _mul(notionalReceivingFloat, benchmarkIndexRatio);\\n\\n\\t\\t/** Apply Effects **/\\n\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\t\\tsupplyIndex = supplyIndexNew;\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\n\\t\\tbenchmarkIndexStored = benchmarkIndexNew;\\n\\t\\tlastAccrualBlock = getBlockNumber();\\n\\n\\t\\temit Accrue(supplierLiquidityNew.val, lockedCollateralNew.val);\\n\\t\\treturn lockedCollateralNew;\\n\\t}\\n\\n\\tfunction transferIn(address from, CTokenAmount memory cTokenAmount) internal {\\n\\t\\trequire(cToken.transferFrom(from, address(this), cTokenAmount.val) == true, \\\"Transfer In Failed\\\");\\n\\t}\\n\\n\\tfunction transferOut(address to, CTokenAmount memory cTokenAmount) internal {\\n\\t\\tif (cTokenAmount.val > 0) {\\n\\t\\t\\trequire(cToken.transfer(to, cTokenAmount.val), \\\"Transfer Out failed\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t// ** PUBLIC PURE HELPERS ** //\\n\\n\\tfunction toCTokens(uint amount, Exp memory cTokenExchangeRate) public pure returns (CTokenAmount memory) {\\n\\t\\tuint cTokenAmount = _div(amount, cTokenExchangeRate);\\n\\t\\treturn CTokenAmount({val: cTokenAmount});\\n\\t}\\n\\n\\tfunction toUnderlying(CTokenAmount memory amount, Exp memory cTokenExchangeRate) public pure returns (uint) {\\n\\t\\treturn _mul(amount.val, cTokenExchangeRate);\\n\\t}\\n\\n\\t// *** PUBLIC VIEW GETTERS *** //\\n\\n\\t// @dev Calculate protocol locked collateral and parBlocks, which is a measure of the fixed rate credit/debt.\\n\\t// * Uses int to keep negatives, for correct late blocks calc when a single swap is outstanding\\n\\tfunction getLockedCollateral(uint accruedBlocks, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory lockedCollateral, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) {\\n\\t\\tparBlocksReceivingFixedNew = _sub(parBlocksReceivingFixed, _mul(accruedBlocks, notionalReceivingFixed));\\n\\t\\tparBlocksPayingFixedNew = _sub(parBlocksPayingFixed, _mul(accruedBlocks, notionalPayingFixed));\\n\\n\\t\\t// Par blocks can be negative during the first or last ever swap, so floor them to 0\\n\\t\\tuint minFloatToReceive = _mul(_toUint(parBlocksPayingFixedNew), minFloatRate);\\n\\t\\tuint maxFloatToPay = _mul(_toUint(parBlocksReceivingFixedNew), maxFloatRate);\\n\\n\\t\\tuint fixedToReceive = _mul(_toUint(parBlocksReceivingFixedNew), avgFixedRateReceiving);\\n\\t\\tuint fixedToPay = _mul(_toUint(parBlocksPayingFixedNew), avgFixedRatePaying);\\n\\n\\t\\tuint minCredit = _add(fixedToReceive, minFloatToReceive);\\n\\t\\tuint maxDebt = _add(fixedToPay, maxFloatToPay);\\n\\n\\t\\tif (maxDebt > minCredit) {\\n\\t\\t\\tlockedCollateral = toCTokens(_sub(maxDebt, minCredit), cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\tlockedCollateral = CTokenAmount({val:0});\\n\\t\\t}\\n\\t}\\n\\n\\t/* @dev Calculate protocol P/L by adding the cashflows since last accrual.\\n\\t * \\t\\tsupplierLiquidity += fixedReceived + floatReceived - fixedPaid - floatPaid\\n\\t */\\n\\tfunction getSupplierLiquidity(uint accruedBlocks, Exp memory floatRate, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory supplierLiquidityNew) {\\n\\t\\tuint floatPaid = _mul(notionalPayingFloat, floatRate);\\n\\t\\tuint floatReceived = _mul(notionalReceivingFloat, floatRate);\\n\\t\\tuint fixedPaid = _mul(accruedBlocks, _mul(notionalPayingFixed, avgFixedRatePaying));\\n\\t\\tuint fixedReceived = _mul(accruedBlocks, _mul(notionalReceivingFixed, avgFixedRateReceiving));\\n\\n\\t\\tCTokenAmount memory rec = toCTokens(_add(fixedReceived, floatReceived), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory paid = toCTokens(_add(fixedPaid, floatPaid), cTokenExchangeRate);\\n\\t\\tsupplierLiquidityNew = _subToZero(_add(supplierLiquidity, rec), paid);\\n\\t}\\n\\n\\t// @dev Get the rate for incoming swaps\\n\\tfunction getSwapRate(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tCTokenAmount memory lockedCollateral,\\n\\t\\tCTokenAmount memory supplierLiquidity_,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) public view returns (Exp memory, int) {\\n\\t\\t(uint ratePerBlockMantissa, int rateFactorNew) = interestRateModel.getSwapRate(\\n\\t\\t\\trateFactor,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\torderNotional,\\n\\t\\t\\ttoUnderlying(lockedCollateral, cTokenExchangeRate),\\n\\t\\t\\ttoUnderlying(supplierLiquidity_, cTokenExchangeRate)\\n\\t\\t);\\n\\t\\treturn (_toExp(ratePerBlockMantissa), rateFactorNew);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the payFixed leg of a swap paying fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (swapFixedRate - minFloatRate)\\n\\tfunction getPayFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = _sub(fixedRate, minFloatRate);\\n\\t\\tuint amt = _mul(_mul(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the receiveFixed leg of a swap receiving fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (maxFloatRate - swapFixedRate)\\n\\tfunction getReceiveFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = _sub(maxFloatRate, fixedRate);\\n\\t\\tuint amt = _mul(_mul(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev Interpolates to get the current borrow index from a compound CToken (or some other similar interface)\\n\\tfunction getBenchmarkIndex() public view returns (Exp memory) {\\n\\t\\tExp memory borrowIndex = _toExp(cToken.borrowIndex());\\n\\t\\trequire(borrowIndex.mantissa != 0, \\\"Benchmark index is zero\\\");\\n\\t\\tuint accrualBlockNumber = cToken.accrualBlockNumber();\\n\\t\\trequire(getBlockNumber() >= accrualBlockNumber, \\\"Bn decreasing\\\");\\n\\t\\tuint blockDelta = _sub(getBlockNumber(), accrualBlockNumber);\\n\\n\\t\\tif (blockDelta == 0) {\\n\\t\\t\\treturn borrowIndex;\\n\\t\\t} else {\\n\\t\\t\\tExp memory borrowRateMantissa = _toExp(cToken.borrowRatePerBlock());\\n\\t\\t\\tExp memory simpleInterestFactor = _mul(borrowRateMantissa, blockDelta);\\n\\t\\t\\treturn _mul(borrowIndex, _add(simpleInterestFactor, ONE_EXP));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getExchangeRate() public view returns (Exp memory) {\\n\\t\\treturn _toExp(cToken.exchangeRateStored());\\n\\t}\\n\\n\\tfunction getBlockNumber() public view virtual returns (uint) {\\n\\t\\treturn block.number;\\n\\t}\\n\\n\\t/** ADMIN FUNCTIONS **/\\n\\n\\tfunction _setInterestRateModel(InterestRateModelInterface newModel) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set interest rate model\\\");\\n\\t\\trequire(newModel != interestRateModel, \\\"Resetting to same model\\\");\\n\\t\\temit SetInterestRateModel(address(newModel), address(interestRateModel));\\n\\t\\tinterestRateModel = newModel;\\n\\t}\\n\\n\\tfunction _setCollateralRequirements(uint minFloatRateMantissa_, uint maxFloatRateMantissa_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set collateral requirements\\\");\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\temit SetCollateralRequirements(minFloatRateMantissa_, maxFloatRateMantissa_);\\n\\t\\tminFloatRate = _toExp(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = _toExp(maxFloatRateMantissa_);\\n\\t}\\n\\n\\tfunction _setLiquidityLimit(uint limit_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set liqiudity limit\\\");\\n\\t\\temit SetLiquidityLimit(limit_);\\n\\t\\tliquidityLimit = CTokenAmount({val: limit_});\\n\\t}\\n\\n\\tfunction _pause(bool isPaused_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to pause\\\");\\n\\t\\trequire(isPaused_ != isPaused, \\\"Must change isPaused\\\");\\n\\t\\temit SetPause(isPaused_);\\n\\t\\tisPaused = isPaused_;\\n\\t}\\n\\n\\tfunction _transferComp(address dest, uint amount) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to transfer comp\\\");\\n\\t\\temit CompTransferred(dest, amount);\\n\\t\\tcomp.transfer(dest, amount);\\n\\t}\\n\\n\\tfunction _delegateComp(address delegatee) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to delegate comp\\\");\\n\\t\\temit CompDelegated(delegatee);\\n\\t\\tcomp.delegate(delegatee);\\n\\t}\\n\\n\\tfunction _changeAdmin(address admin_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to change admin\\\");\\n\\t\\temit AdminChanged(admin, admin_);\\n\\t\\tadmin = admin_;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xba5537c4bfd0b58acb50c9619c3eb173343af4d88ebe599094a2860ed6796aaa\"},\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"},\"contracts/test/FaucetToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StandardToken.sol\\\";\\n\\ncontract FaucetToken is StandardToken {\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\\n        totalSupply_ = _initialAmount;\\n        balances[msg.sender] = _initialAmount;\\n        name = _tokenName;\\n        symbol = _tokenSymbol;\\n        decimals = _decimalUnits;\\n    }\\n\\n    function allocateTo(address _owner, uint256 value) public {\\n        balances[_owner] += value;\\n        totalSupply_ += value;\\n        emit Transfer(address(this), _owner, value);\\n    }\\n}\\n\",\"keccak256\":\"0xf4ea18824410d4a0b355ab4a738ca788384aea817c38bef9610353d277aa1804\"},\"contracts/test/MockCToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"../Rho.sol\\\";\\nimport \\\"./FaucetToken.sol\\\";\\n\\ninterface MockCTokenInterface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\ncontract MockCToken is FaucetToken, MockCTokenInterface {\\n\\n\\tuint public override borrowIndex = 1e18;\\n\\tuint public override accrualBlockNumber = 100;\\n\\tuint public override borrowRatePerBlock;\\n\\n\\tuint public exchangeRate;\\n\\n\\tconstructor(\\n\\t\\tuint _initialExchangeRate,\\n\\t\\tuint _borrowRatePerBlockMantissa,\\n\\t\\tuint256 _initialAmount,\\n\\t\\tstring memory _tokenName,\\n\\t\\tuint8 _decimalUnits,\\n\\t\\tstring memory _tokenSymbol\\n\\t)\\n\\t\\tpublic FaucetToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol)\\n\\t{\\n\\t\\tborrowRatePerBlock = _borrowRatePerBlockMantissa;\\n\\t\\texchangeRate = _initialExchangeRate * 1e18;\\n\\t}\\n\\n\\tfunction setBorrowIndex(uint borrowIndex_) public {\\n\\t\\tborrowIndex = borrowIndex_;\\n\\t}\\n\\n\\tfunction setAccrualBlockNumber(uint bn) public {\\n\\t\\taccrualBlockNumber = bn;\\n\\t}\\n\\n\\tfunction advanceBlocks(uint blocks) public {\\n\\t\\taccrualBlockNumber += blocks;\\n\\t}\\n\\n\\tfunction exchangeRateStored() public override view returns (uint) {\\n\\t\\treturn exchangeRate;\\n\\t}\\n}\\n\",\"keccak256\":\"0x88c3eef595aa41fae9580333ff8d9d80243897a5c5ec40ef0e73af1b0022b279\"},\"contracts/test/SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xabba6407e3cc0e14aa98d71eac7c59513b9b68b4ac734293ac2dbab9d5cb3dfb\"},\"contracts/test/StandardToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\nabstract contract ERC20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n    function balanceOf(address who) public view virtual returns (uint256);\\n    function transfer(address to, uint256 value) public virtual returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) balances;\\n\\n    uint256 totalSupply_;\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() public view override returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        require(_to != address(0));\\n        require(_value <= balances[msg.sender], \\\"Transfer: insufficient balance\\\");\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param _owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address _owner) public view override returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n}\\n\\n\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\nabstract contract ERC20 is ERC20Basic {\\n    function allowance(address owner, address spender) public view virtual returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\\n    function approve(address spender, uint256 value) public virtual returns (bool);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/issues/20\\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n    mapping (address => mapping (address => uint256)) internal allowed;\\n\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(_to != address(0), \\\"TransferFrom: Can't send to address zero\\\");\\n        require(_value <= balances[_from], \\\"TransferFrom: Inadequate balance\\\");\\n        require(_value <= allowed[_from][msg.sender], \\\"TransferFrom: Inadequate allowance\\\");\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param _spender The address which will spend the funds.\\n     * @param _value The amount of tokens to be spent.\\n     */\\n    function approve(address _spender, uint256 _value) public override returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n     )\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (\\n            allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue > oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x33a81ce8e70f59fe7a0d01872dc70e6c46fe7b90dd983c960f074ee907feb93e\"}},\"version\":1}"},"contracts/test/MockCToken.sol:MockCTokenInterface":{"abi":"[{\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","bin":"","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/test/MockCToken.sol\":\"MockCTokenInterface\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Math.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\n/* @dev A safe math lib for Rho data types. \\n   Note: always returns type of left side param */\\ncontract Math is Types {\\n\\n\\tuint constant EXP_SCALE = 1e18;\\n    Exp ONE_EXP = Exp({mantissa: EXP_SCALE});\\n\\n    function _toExp(uint num) pure internal returns (Exp memory) {\\n    \\treturn Exp({mantissa: num});\\n    }\\n\\n    function _toUint(int a) pure internal returns (uint) {\\n        return a > 0 ? uint(a) : 0;\\n    }\\n\\n    function _lt(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val < b.val;\\n    }\\n\\n    function _lte(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val <= b.val;\\n    }\\n\\n    function _add(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _add(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _add(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _add(a.val, b.val)});\\n    }\\n\\n    function _add(uint a, uint b) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function _sub(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _sub(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _subToZero(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        if (b.val >= a.val) {\\n            return CTokenAmount({val: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(uint a, uint b) pure internal returns (uint) {\\n        if (b >= a) {\\n            return 0;\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        if (b.mantissa >= a.mantissa) {\\n            return Exp({mantissa: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _sub(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _sub(a.val, b.val)});\\n    }\\n\\n    function _sub(uint a, uint b) pure internal returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function _sub(int a, uint b) pure internal returns (int) {\\n        int c = a - int(b);\\n        require(a >= c, \\\"int - uint underflow\\\");\\n        return c;\\n    }\\n\\n    function _add(int a, uint b) pure internal returns (int) {\\n        int c = a + int(b);\\n        require(a <= c, \\\"int + uint overflow\\\");\\n        return c;\\n    }\\n\\n    function _mul(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _mul(a, b.val);\\n    }\\n\\n    function _mul(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _mul(a.val, b)});\\n    }\\n\\n    function _mul(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b.mantissa) / EXP_SCALE});\\n    }\\n\\n    function _mul(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b)});\\n    }\\n\\n    function _mul(uint a, Exp memory b) pure internal returns (uint) {\\n        return _mul(a, b.mantissa) / EXP_SCALE;\\n    }\\n\\n    function _mul(uint a, uint b) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function _div(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _div(a, b.val);\\n    }\\n\\n    function _div(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _div(a.val, b)});\\n    }\\n\\n    function _div(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(_mul(a.mantissa, EXP_SCALE), b.mantissa)});\\n    }\\n\\n    function _div(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(a.mantissa, b)});\\n    }\\n\\n    function _div(uint a, Exp memory b) pure internal returns (uint) {\\n        return _div(_mul(a, EXP_SCALE), b.mantissa);\\n    }\\n\\n    function _div(uint a, uint b) pure internal returns (uint) {\\n        require(b > 0, \\\"divide by zero\\\");\\n        return a / b;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x8c6200920feaf6aa32f936d0daf59a94bc84b9b5808c425db8b1eba60bd65e06\"},\"contracts/Rho.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Math.sol\\\";\\nimport {RhoInterface, CTokenInterface, CompInterface, InterestRateModelInterface} from \\\"./RhoInterfaces.sol\\\";\\n\\n/* @dev:\\n * CTokens are used as collateral. \\\"Underlying\\\" in Rho refers to the collateral CToken's underlying token.\\n * An Exp is a data type with 18 decimals, used for scaling up and precise calculations */\\ncontract Rho is RhoInterface, Math {\\n\\n\\tCTokenInterface public immutable cToken;\\n\\tCompInterface public immutable comp;\\n\\n\\tuint public immutable SWAP_MIN_DURATION;\\n\\tuint public immutable SUPPLY_MIN_DURATION;\\n\\tuint public immutable MIN_SWAP_NOTIONAL = 1e18;\\n\\tuint public immutable CLOSE_GRACE_PERIOD_BLOCKS = 3000; // ~12.5 hrs\\n\\tuint public immutable CLOSE_PENALTY_PER_BLOCK_MANTISSA = 1e14;// 1% (1e16) every 25 min (100 blocks)\\n\\n\\tconstructor (\\n\\t\\tInterestRateModelInterface interestRateModel_,\\n\\t\\tCTokenInterface cToken_,\\n\\t\\tCompInterface comp_,\\n\\t\\tuint minFloatRateMantissa_,\\n\\t\\tuint maxFloatRateMantissa_,\\n\\t\\tuint swapMinDuration_,\\n\\t\\tuint supplyMinDuration_,\\n\\t\\taddress admin_,\\n\\t\\tuint liquidityLimitCTokens_\\n\\t) public {\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\tinterestRateModel = interestRateModel_;\\n\\t\\tcToken = cToken_;\\n\\t\\tcomp = comp_;\\n\\t\\tminFloatRate = _toExp(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = _toExp(maxFloatRateMantissa_);\\n\\t\\tSWAP_MIN_DURATION = swapMinDuration_;\\n\\t\\tSUPPLY_MIN_DURATION = supplyMinDuration_;\\n\\t\\tadmin = admin_;\\n\\n\\t\\tsupplyIndex = ONE_EXP.mantissa;\\n\\t\\tbenchmarkIndexStored = _toExp(cToken_.borrowIndex());\\n\\t\\tisPaused = false;\\n\\t\\tliquidityLimit = CTokenAmount({val:liquidityLimitCTokens_});\\n\\t}\\n\\n\\t/* @dev Supplies liquidity to the protocol. Become the counterparty for all swap traders, in return for fees.\\n\\t * @param cTokenSupplyAmount Amount to supply, in CTokens.\\n\\t */\\n\\tfunction supply(uint cTokenSupplyAmount) public override {\\n\\t\\tCTokenAmount memory supplyAmount = CTokenAmount({val: cTokenSupplyAmount});\\n\\t\\tCTokenAmount memory supplierLiquidityNew = _add(supplierLiquidity, supplyAmount);\\n\\t\\t\\n\\t\\trequire(_lt(supplierLiquidityNew, liquidityLimit), \\\"Supply paused, above liquidity limit\\\");\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory prevSupply = supplyAccounts[msg.sender].amount;\\n\\n\\t\\tCTokenAmount memory truedUpPrevSupply;\\n\\t\\tif (prevSupply.val == 0) {\\n\\t\\t\\ttruedUpPrevSupply = CTokenAmount({val: 0});\\n\\t\\t} else {\\n\\t\\t\\tuint prevIndex = supplyAccounts[msg.sender].index;\\n\\t\\t\\ttruedUpPrevSupply = _div(_mul(prevSupply, supplyIndex), prevIndex);\\n\\t\\t}\\n\\n\\t\\tCTokenAmount memory newSupplyAmount = _add(truedUpPrevSupply, supplyAmount);\\n\\n\\t\\temit Supply(msg.sender, cTokenSupplyAmount, newSupplyAmount.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].amount = newSupplyAmount;\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\n\\t\\ttransferIn(msg.sender, supplyAmount);\\n\\t}\\n\\n\\t/* @dev Remove liquidity from protocol. Can only perform after a waiting period from supplying, to prevent interest rate manipulation\\n\\t * @param removeCTokenAmount Amount of CTokens to remove. 0 removes all CTokens.\\n\\t */\\n\\tfunction remove(uint removeCTokenAmount) public override {\\n\\t\\tCTokenAmount memory removeAmount = CTokenAmount({val: removeCTokenAmount});\\n\\t\\tSupplyAccount memory account = supplyAccounts[msg.sender];\\n\\t\\trequire(account.amount.val > 0, \\\"Must withdraw from active account\\\");\\n\\t\\trequire(getBlockNumber() - account.lastBlock >= SUPPLY_MIN_DURATION, \\\"Liquidity must be supplied a minimum duration\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory truedUpAccountValue = _div(_mul(account.amount, supplyIndex), account.index);\\n\\n\\t\\t// Remove all liquidity\\n\\t\\tif (removeAmount.val == 0) {\\n\\t\\t\\tremoveAmount = truedUpAccountValue;\\n\\t\\t}\\n\\t\\trequire(_lte(removeAmount, truedUpAccountValue), \\\"Trying to remove more than account value\\\");\\n\\t\\tCTokenAmount memory unlockedCollateral = _sub(supplierLiquidity, lockedCollateral);\\n\\t\\t\\n\\t\\trequire(_lte(removeAmount, unlockedCollateral), \\\"Removing more liquidity than is unlocked\\\");\\n\\t\\trequire(_lte(removeAmount, supplierLiquidity), \\\"Removing more than total supplier liquidity\\\");\\n\\n\\t\\tCTokenAmount memory newAccountValue = _sub(truedUpAccountValue, removeAmount);\\n\\n\\t\\temit Remove(msg.sender, removeCTokenAmount, newAccountValue.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\t\\tsupplyAccounts[msg.sender].amount = newAccountValue;\\n\\n\\t\\tsupplierLiquidity = _sub(supplierLiquidity, removeAmount);\\n\\n\\t\\ttransferOut(msg.sender, removeAmount);\\n\\t}\\n\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(true, notionalAmount, maximumFixedRateMantissa);\\n\\t}\\n\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(false, notionalAmount, minFixedRateMantissa);\\n\\t}\\n\\n\\t/* @dev Opens a new interest rate swap\\n\\t * @param userPayingFixed : The user can choose if they want to receive fixed or pay fixed (the protocol will take the opposite side)\\n\\t * @param notionalAmount : The principal that interest rate payments will be based on\\n\\t * @param fixedRateLimitMantissa : The maximum (if payingFixed) or minimum (if receivingFixed) rate the swap should succeed at. Prevents frontrunning attacks.\\n\\t \\t* The amount of interest to pay over 2,102,400 blocks (~1 year), with 18 decimals of precision. Eg: 5% per block-year => 0.5e18.\\n\\t*/\\n\\tfunction openInternal(bool userPayingFixed, uint notionalAmount, uint fixedRateLimitMantissa) internal returns (bytes32 swapHash) {\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\t\\trequire(notionalAmount >= MIN_SWAP_NOTIONAL, \\\"Swap notional amount must exceed minimum\\\");\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityTemp = supplierLiquidity; // copy to memory for gas\\n\\t\\trequire(_lt(supplierLiquidityTemp, liquidityLimit), \\\"Open paused, above liquidity limit\\\");\\n\\t\\t\\n\\t\\t(Exp memory swapFixedRate, int rateFactorNew) = getSwapRate(userPayingFixed, notionalAmount, lockedCollateral, supplierLiquidityTemp, cTokenExchangeRate);\\n\\t\\tCTokenAmount memory userCollateralCTokens;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\trequire(swapFixedRate.mantissa <= fixedRateLimitMantissa, \\\"The fixed rate Rho would receive is above user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = _add(lockedCollateral, getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(_lte(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openPayFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\trequire(swapFixedRate.mantissa >= fixedRateLimitMantissa, \\\"The fixed rate Rho would pay is below user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = _add(lockedCollateral, getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(_lte(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openReceiveFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t}\\n\\n\\t\\tswapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t));\\n\\n\\t\\trequire(swaps[swapHash] == false, \\\"Duplicate swap\\\");\\n\\n\\t\\temit OpenSwap(\\n\\t\\t\\tswapHash,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t);\\n\\n\\t\\tswaps[swapHash] = true;\\n\\t\\trateFactor = rateFactorNew;\\n\\t\\ttransferIn(msg.sender, userCollateralCTokens);\\n\\t}\\n\\n\\n\\t// @dev User is paying fixed, protocol is receiving fixed\\n\\tfunction openPayFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalReceivingFixedNew = _add(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = _add(notionalPayingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksReceivingFixedNew = _add(parBlocksReceivingFixed, _mul(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRateReceivingNew = (avgFixedRateReceiving * notionalReceivingFixed + notionalAmount * swapFixedRate) / (notionalReceivingFixed + notionalAmount);*/\\n\\t\\tExp memory priorFixedReceivingRate = _mul(avgFixedRateReceiving, notionalReceivingFixed);\\n\\t\\tExp memory orderFixedReceivingRate = _mul(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRateReceivingNew = _div(_add(priorFixedReceivingRate, orderFixedReceivingRate), notionalReceivingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t// @dev User is receiving fixed, protocol is paying fixed\\n\\tfunction openReceiveFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalPayingFixedNew = _add(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = _add(notionalReceivingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksPayingFixedNew = _add(parBlocksPayingFixed, _mul(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRatePayingNew = (avgFixedRatePaying * notionalPayingFixed + notionalAmount * swapFixedRate) / (notionalPayingFixed + notionalAmount) */\\n\\t\\tExp memory priorFixedPayingRate = _mul(avgFixedRatePaying, notionalPayingFixed);\\n\\t\\tExp memory orderFixedPayingRate = _mul(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRatePayingNew = _div(_add(priorFixedPayingRate, orderFixedPayingRate), notionalPayingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t/* @dev Closes an existing swap, after the min swap duration. Float payment continues even if closed late.\\n\\t * Takes params from Open event.\\n\\t * Take caution not to unecessarily revert due to underflow / overflow, as uncloseable swaps are very dangerous.\\n\\t */\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) public override {\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tbytes32 swapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexInit,\\n\\t\\t\\tinitBlock,\\n\\t\\t\\tswapFixedRateMantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens,\\n\\t\\t\\towner\\n\\t\\t));\\n\\t\\trequire(swaps[swapHash] == true, \\\"No active swap found\\\");\\n\\t\\tuint swapDuration = _sub(getBlockNumber(), initBlock);\\n\\t\\trequire(swapDuration >= SWAP_MIN_DURATION, \\\"Premature close swap\\\");\\n\\t\\tExp memory benchmarkIndexRatio = _div(benchmarkIndexStored, _toExp(benchmarkIndexInit));\\n\\n\\t\\tCTokenAmount memory userCollateral = CTokenAmount({val: userCollateralCTokens});\\n\\t\\tExp memory swapFixedRate = _toExp(swapFixedRateMantissa);\\n\\n\\t\\tCTokenAmount memory userPayout;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\tuserPayout = closePayFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tuserPayout = closeReceiveFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tuint bal = cToken.balanceOf(address(this));\\n\\n\\t\\t// Payout is capped by total balance\\n\\t\\tif (userPayout.val > bal) userPayout = CTokenAmount({val: bal});\\n\\n\\t\\tuint lateBlocks = _sub(swapDuration, SWAP_MIN_DURATION);\\n\\t\\tCTokenAmount memory penalty = CTokenAmount(0);\\n\\n\\t\\tif (lateBlocks > CLOSE_GRACE_PERIOD_BLOCKS) {\\n\\t\\t\\tuint penaltyBlocks = lateBlocks - CLOSE_GRACE_PERIOD_BLOCKS;\\n\\t\\t\\tExp memory penaltyPercent = _mul(_toExp(CLOSE_PENALTY_PER_BLOCK_MANTISSA), penaltyBlocks);\\n\\t\\t\\tpenaltyPercent = ONE_EXP.mantissa > penaltyPercent.mantissa ? penaltyPercent : ONE_EXP; // maximum of 100% penalty\\n\\t\\t\\tpenalty = CTokenAmount(_mul(userPayout.val, penaltyPercent));\\n\\t\\t\\tuserPayout = _sub(userPayout, penalty);\\n\\t\\t}\\n\\n\\t\\temit CloseSwap(swapHash, owner, userPayout.val, penalty.val, benchmarkIndexStored.mantissa);\\n\\n\\t\\tswaps[swapHash] = false;\\n\\t\\ttransferOut(owner, userPayout);\\n\\t\\ttransferOut(msg.sender, penalty);\\n\\t}\\n\\n\\t// @dev User paid fixed, protocol paid fixed\\n\\tfunction closePayFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalReceivingFixedNew = _subToZero(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = _subToZero(notionalPayingFloat, _mul(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRateReceiving = avgFixedRateReceiving * notionalReceivingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRateReceivingNew;\\n\\t\\tif (notionalReceivingFixedNew == 0){\\n\\t\\t\\tavgFixedRateReceivingNew = _toExp(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = _subToZero(_mul(avgFixedRateReceiving, notionalReceivingFixed), _mul(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRateReceivingNew = _div(numerator, notionalReceivingFixedNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksReceivingFixedNew = _add(parBlocksReceivingFixed, _mul(notionalAmount, _sub(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(_mul(_mul(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(_mul(notionalAmount, _sub(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = _subToZero(_add(userCollateral, floatLeg), fixedLeg); // no underflows\\n\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t// @dev User received fixed, protocol paid fixed\\n\\tfunction closeReceiveFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalPayingFixedNew = _subToZero(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = _subToZero(notionalReceivingFloat, _mul(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRatePaying = avgFixedRatePaying * notionalPayingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRatePayingNew;\\n\\t\\tif (notionalPayingFixedNew == 0) {\\n\\t\\t\\tavgFixedRatePayingNew = _toExp(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = _subToZero(_mul(avgFixedRatePaying, notionalPayingFixed), _mul(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRatePayingNew = _div(numerator, notionalReceivingFloatNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksPayingFixedNew = _add(parBlocksPayingFixed, _mul(notionalAmount, _sub(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(_mul(_mul(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(_mul(notionalAmount, _sub(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = _subToZero(_add(userCollateral, fixedLeg), floatLeg);\\n\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t/* @dev Called internally at the beginning of external swap and liquidity provider functions.\\n\\t * WRITES TO STORAGE\\n\\t * Accounts for interest rate payments and adjust collateral requirements with the passage of time.\\n\\t * @return lockedCollateralNew : The amount of collateral the protocol needs to keep locked.\\n\\t */\\n\\tfunction accrue(Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory) {\\n\\t\\trequire(getBlockNumber() >= lastAccrualBlock, \\\"Block number decreasing\\\");\\n\\t\\tuint accruedBlocks = getBlockNumber() - lastAccrualBlock;\\n\\t\\t(CTokenAmount memory lockedCollateralNew, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) = getLockedCollateral(accruedBlocks, cTokenExchangeRate);\\n\\n\\t\\tif (accruedBlocks == 0) {\\n\\t\\t\\treturn lockedCollateralNew;\\n\\t\\t}\\n\\n\\t\\tExp memory benchmarkIndexNew = getBenchmarkIndex();\\n\\t\\tExp memory benchmarkIndexRatio = _div(benchmarkIndexNew, benchmarkIndexStored);\\n\\t\\tExp memory floatRate = _sub(benchmarkIndexRatio, ONE_EXP);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityNew = getSupplierLiquidity(accruedBlocks, floatRate, cTokenExchangeRate);\\n\\n\\t\\t// supplyIndex *= supplierLiquidityNew / supplierLiquidity\\n\\t\\tuint supplyIndexNew = supplyIndex;\\n\\t\\tif (supplierLiquidityNew.val != 0) {\\n\\t\\t\\tsupplyIndexNew = _div(_mul(supplyIndex, supplierLiquidityNew), supplierLiquidity);\\n\\t\\t}\\n\\n\\t\\tuint notionalPayingFloatNew = _mul(notionalPayingFloat, benchmarkIndexRatio);\\n\\t\\tuint notionalReceivingFloatNew = _mul(notionalReceivingFloat, benchmarkIndexRatio);\\n\\n\\t\\t/** Apply Effects **/\\n\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\t\\tsupplyIndex = supplyIndexNew;\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\n\\t\\tbenchmarkIndexStored = benchmarkIndexNew;\\n\\t\\tlastAccrualBlock = getBlockNumber();\\n\\n\\t\\temit Accrue(supplierLiquidityNew.val, lockedCollateralNew.val);\\n\\t\\treturn lockedCollateralNew;\\n\\t}\\n\\n\\tfunction transferIn(address from, CTokenAmount memory cTokenAmount) internal {\\n\\t\\trequire(cToken.transferFrom(from, address(this), cTokenAmount.val) == true, \\\"Transfer In Failed\\\");\\n\\t}\\n\\n\\tfunction transferOut(address to, CTokenAmount memory cTokenAmount) internal {\\n\\t\\tif (cTokenAmount.val > 0) {\\n\\t\\t\\trequire(cToken.transfer(to, cTokenAmount.val), \\\"Transfer Out failed\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t// ** PUBLIC PURE HELPERS ** //\\n\\n\\tfunction toCTokens(uint amount, Exp memory cTokenExchangeRate) public pure returns (CTokenAmount memory) {\\n\\t\\tuint cTokenAmount = _div(amount, cTokenExchangeRate);\\n\\t\\treturn CTokenAmount({val: cTokenAmount});\\n\\t}\\n\\n\\tfunction toUnderlying(CTokenAmount memory amount, Exp memory cTokenExchangeRate) public pure returns (uint) {\\n\\t\\treturn _mul(amount.val, cTokenExchangeRate);\\n\\t}\\n\\n\\t// *** PUBLIC VIEW GETTERS *** //\\n\\n\\t// @dev Calculate protocol locked collateral and parBlocks, which is a measure of the fixed rate credit/debt.\\n\\t// * Uses int to keep negatives, for correct late blocks calc when a single swap is outstanding\\n\\tfunction getLockedCollateral(uint accruedBlocks, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory lockedCollateral, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) {\\n\\t\\tparBlocksReceivingFixedNew = _sub(parBlocksReceivingFixed, _mul(accruedBlocks, notionalReceivingFixed));\\n\\t\\tparBlocksPayingFixedNew = _sub(parBlocksPayingFixed, _mul(accruedBlocks, notionalPayingFixed));\\n\\n\\t\\t// Par blocks can be negative during the first or last ever swap, so floor them to 0\\n\\t\\tuint minFloatToReceive = _mul(_toUint(parBlocksPayingFixedNew), minFloatRate);\\n\\t\\tuint maxFloatToPay = _mul(_toUint(parBlocksReceivingFixedNew), maxFloatRate);\\n\\n\\t\\tuint fixedToReceive = _mul(_toUint(parBlocksReceivingFixedNew), avgFixedRateReceiving);\\n\\t\\tuint fixedToPay = _mul(_toUint(parBlocksPayingFixedNew), avgFixedRatePaying);\\n\\n\\t\\tuint minCredit = _add(fixedToReceive, minFloatToReceive);\\n\\t\\tuint maxDebt = _add(fixedToPay, maxFloatToPay);\\n\\n\\t\\tif (maxDebt > minCredit) {\\n\\t\\t\\tlockedCollateral = toCTokens(_sub(maxDebt, minCredit), cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\tlockedCollateral = CTokenAmount({val:0});\\n\\t\\t}\\n\\t}\\n\\n\\t/* @dev Calculate protocol P/L by adding the cashflows since last accrual.\\n\\t * \\t\\tsupplierLiquidity += fixedReceived + floatReceived - fixedPaid - floatPaid\\n\\t */\\n\\tfunction getSupplierLiquidity(uint accruedBlocks, Exp memory floatRate, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory supplierLiquidityNew) {\\n\\t\\tuint floatPaid = _mul(notionalPayingFloat, floatRate);\\n\\t\\tuint floatReceived = _mul(notionalReceivingFloat, floatRate);\\n\\t\\tuint fixedPaid = _mul(accruedBlocks, _mul(notionalPayingFixed, avgFixedRatePaying));\\n\\t\\tuint fixedReceived = _mul(accruedBlocks, _mul(notionalReceivingFixed, avgFixedRateReceiving));\\n\\n\\t\\tCTokenAmount memory rec = toCTokens(_add(fixedReceived, floatReceived), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory paid = toCTokens(_add(fixedPaid, floatPaid), cTokenExchangeRate);\\n\\t\\tsupplierLiquidityNew = _subToZero(_add(supplierLiquidity, rec), paid);\\n\\t}\\n\\n\\t// @dev Get the rate for incoming swaps\\n\\tfunction getSwapRate(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tCTokenAmount memory lockedCollateral,\\n\\t\\tCTokenAmount memory supplierLiquidity_,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) public view returns (Exp memory, int) {\\n\\t\\t(uint ratePerBlockMantissa, int rateFactorNew) = interestRateModel.getSwapRate(\\n\\t\\t\\trateFactor,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\torderNotional,\\n\\t\\t\\ttoUnderlying(lockedCollateral, cTokenExchangeRate),\\n\\t\\t\\ttoUnderlying(supplierLiquidity_, cTokenExchangeRate)\\n\\t\\t);\\n\\t\\treturn (_toExp(ratePerBlockMantissa), rateFactorNew);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the payFixed leg of a swap paying fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (swapFixedRate - minFloatRate)\\n\\tfunction getPayFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = _sub(fixedRate, minFloatRate);\\n\\t\\tuint amt = _mul(_mul(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the receiveFixed leg of a swap receiving fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (maxFloatRate - swapFixedRate)\\n\\tfunction getReceiveFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = _sub(maxFloatRate, fixedRate);\\n\\t\\tuint amt = _mul(_mul(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev Interpolates to get the current borrow index from a compound CToken (or some other similar interface)\\n\\tfunction getBenchmarkIndex() public view returns (Exp memory) {\\n\\t\\tExp memory borrowIndex = _toExp(cToken.borrowIndex());\\n\\t\\trequire(borrowIndex.mantissa != 0, \\\"Benchmark index is zero\\\");\\n\\t\\tuint accrualBlockNumber = cToken.accrualBlockNumber();\\n\\t\\trequire(getBlockNumber() >= accrualBlockNumber, \\\"Bn decreasing\\\");\\n\\t\\tuint blockDelta = _sub(getBlockNumber(), accrualBlockNumber);\\n\\n\\t\\tif (blockDelta == 0) {\\n\\t\\t\\treturn borrowIndex;\\n\\t\\t} else {\\n\\t\\t\\tExp memory borrowRateMantissa = _toExp(cToken.borrowRatePerBlock());\\n\\t\\t\\tExp memory simpleInterestFactor = _mul(borrowRateMantissa, blockDelta);\\n\\t\\t\\treturn _mul(borrowIndex, _add(simpleInterestFactor, ONE_EXP));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getExchangeRate() public view returns (Exp memory) {\\n\\t\\treturn _toExp(cToken.exchangeRateStored());\\n\\t}\\n\\n\\tfunction getBlockNumber() public view virtual returns (uint) {\\n\\t\\treturn block.number;\\n\\t}\\n\\n\\t/** ADMIN FUNCTIONS **/\\n\\n\\tfunction _setInterestRateModel(InterestRateModelInterface newModel) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set interest rate model\\\");\\n\\t\\trequire(newModel != interestRateModel, \\\"Resetting to same model\\\");\\n\\t\\temit SetInterestRateModel(address(newModel), address(interestRateModel));\\n\\t\\tinterestRateModel = newModel;\\n\\t}\\n\\n\\tfunction _setCollateralRequirements(uint minFloatRateMantissa_, uint maxFloatRateMantissa_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set collateral requirements\\\");\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\temit SetCollateralRequirements(minFloatRateMantissa_, maxFloatRateMantissa_);\\n\\t\\tminFloatRate = _toExp(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = _toExp(maxFloatRateMantissa_);\\n\\t}\\n\\n\\tfunction _setLiquidityLimit(uint limit_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set liqiudity limit\\\");\\n\\t\\temit SetLiquidityLimit(limit_);\\n\\t\\tliquidityLimit = CTokenAmount({val: limit_});\\n\\t}\\n\\n\\tfunction _pause(bool isPaused_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to pause\\\");\\n\\t\\trequire(isPaused_ != isPaused, \\\"Must change isPaused\\\");\\n\\t\\temit SetPause(isPaused_);\\n\\t\\tisPaused = isPaused_;\\n\\t}\\n\\n\\tfunction _transferComp(address dest, uint amount) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to transfer comp\\\");\\n\\t\\temit CompTransferred(dest, amount);\\n\\t\\tcomp.transfer(dest, amount);\\n\\t}\\n\\n\\tfunction _delegateComp(address delegatee) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to delegate comp\\\");\\n\\t\\temit CompDelegated(delegatee);\\n\\t\\tcomp.delegate(delegatee);\\n\\t}\\n\\n\\tfunction _changeAdmin(address admin_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to change admin\\\");\\n\\t\\temit AdminChanged(admin, admin_);\\n\\t\\tadmin = admin_;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xba5537c4bfd0b58acb50c9619c3eb173343af4d88ebe599094a2860ed6796aaa\"},\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"},\"contracts/test/FaucetToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StandardToken.sol\\\";\\n\\ncontract FaucetToken is StandardToken {\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\\n        totalSupply_ = _initialAmount;\\n        balances[msg.sender] = _initialAmount;\\n        name = _tokenName;\\n        symbol = _tokenSymbol;\\n        decimals = _decimalUnits;\\n    }\\n\\n    function allocateTo(address _owner, uint256 value) public {\\n        balances[_owner] += value;\\n        totalSupply_ += value;\\n        emit Transfer(address(this), _owner, value);\\n    }\\n}\\n\",\"keccak256\":\"0xf4ea18824410d4a0b355ab4a738ca788384aea817c38bef9610353d277aa1804\"},\"contracts/test/MockCToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"../Rho.sol\\\";\\nimport \\\"./FaucetToken.sol\\\";\\n\\ninterface MockCTokenInterface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\ncontract MockCToken is FaucetToken, MockCTokenInterface {\\n\\n\\tuint public override borrowIndex = 1e18;\\n\\tuint public override accrualBlockNumber = 100;\\n\\tuint public override borrowRatePerBlock;\\n\\n\\tuint public exchangeRate;\\n\\n\\tconstructor(\\n\\t\\tuint _initialExchangeRate,\\n\\t\\tuint _borrowRatePerBlockMantissa,\\n\\t\\tuint256 _initialAmount,\\n\\t\\tstring memory _tokenName,\\n\\t\\tuint8 _decimalUnits,\\n\\t\\tstring memory _tokenSymbol\\n\\t)\\n\\t\\tpublic FaucetToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol)\\n\\t{\\n\\t\\tborrowRatePerBlock = _borrowRatePerBlockMantissa;\\n\\t\\texchangeRate = _initialExchangeRate * 1e18;\\n\\t}\\n\\n\\tfunction setBorrowIndex(uint borrowIndex_) public {\\n\\t\\tborrowIndex = borrowIndex_;\\n\\t}\\n\\n\\tfunction setAccrualBlockNumber(uint bn) public {\\n\\t\\taccrualBlockNumber = bn;\\n\\t}\\n\\n\\tfunction advanceBlocks(uint blocks) public {\\n\\t\\taccrualBlockNumber += blocks;\\n\\t}\\n\\n\\tfunction exchangeRateStored() public override view returns (uint) {\\n\\t\\treturn exchangeRate;\\n\\t}\\n}\\n\",\"keccak256\":\"0x88c3eef595aa41fae9580333ff8d9d80243897a5c5ec40ef0e73af1b0022b279\"},\"contracts/test/SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xabba6407e3cc0e14aa98d71eac7c59513b9b68b4ac734293ac2dbab9d5cb3dfb\"},\"contracts/test/StandardToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\nabstract contract ERC20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n    function balanceOf(address who) public view virtual returns (uint256);\\n    function transfer(address to, uint256 value) public virtual returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) balances;\\n\\n    uint256 totalSupply_;\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() public view override returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        require(_to != address(0));\\n        require(_value <= balances[msg.sender], \\\"Transfer: insufficient balance\\\");\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param _owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address _owner) public view override returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n}\\n\\n\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\nabstract contract ERC20 is ERC20Basic {\\n    function allowance(address owner, address spender) public view virtual returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\\n    function approve(address spender, uint256 value) public virtual returns (bool);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/issues/20\\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n    mapping (address => mapping (address => uint256)) internal allowed;\\n\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(_to != address(0), \\\"TransferFrom: Can't send to address zero\\\");\\n        require(_value <= balances[_from], \\\"TransferFrom: Inadequate balance\\\");\\n        require(_value <= allowed[_from][msg.sender], \\\"TransferFrom: Inadequate allowance\\\");\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param _spender The address which will spend the funds.\\n     * @param _value The amount of tokens to be spent.\\n     */\\n    function approve(address _spender, uint256 _value) public override returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n     )\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (\\n            allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue > oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x33a81ce8e70f59fe7a0d01872dc70e6c46fe7b90dd983c960f074ee907feb93e\"}},\"version\":1}"},"contracts/test/MockInterestRateModel.sol:MockInterestRateModel":{"abi":"[{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"rateFactorPrev\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplierLiquidityUnderlying\",\"type\":\"uint256\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rateFactorNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate_\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","bin":"60806040526402540be40060005534801561001957600080fd5b50610112806100296000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c806327fc002414604157806334fcf43714608e578063e8f9438f1460aa575b600080fd5b6075600480360360a0811015605557600080fd5b5080359060208101351515906040810135906060810135906080013560c2565b6040805192835260208301919091528051918290030190f35b60a86004803603602081101560a257600080fd5b503560d1565b005b60b060d6565b60408051918252519081900360200190f35b60005460019550959350505050565b600055565b6000548156fea2646970667358221220b801822effad423d66d8063346990089f6f497aba209ef1849ccea8b4111bc5964736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"rateFactorPrev\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplierLiquidityUnderlying\",\"type\":\"uint256\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rateFactorNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate_\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/test/MockInterestRateModel.sol\":\"MockInterestRateModel\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/InterestRateModel.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport {InterestRateModelInterface} from \\\"./RhoInterfaces.sol\\\";\\n\\ncontract InterestRateModel is InterestRateModelInterface {\\n\\n\\tuint public immutable yOffset;\\n\\tuint public immutable slopeFactor;\\n\\tuint public immutable rateFactorSensitivity;\\n\\tuint public immutable range;\\n\\tuint public immutable feeBase;\\n\\tuint public immutable feeSensitivity;\\n\\n\\tconstructor(\\n\\t\\tuint yOffset_,\\n\\t\\tuint slopeFactor_,\\n\\t\\tuint rateFactorSensitivity_,\\n\\t\\tuint feeBase_,\\n\\t\\tuint feeSensitivity_,\\n\\t\\tuint range_\\n\\t) public {\\n\\t\\trequire(slopeFactor_ > 0 && rateFactorSensitivity_ > 0 && range_ > 0 , \\\"Zero params not allowed\\\");\\n\\n\\t\\tyOffset = yOffset_;\\n\\t\\tslopeFactor = slopeFactor_;\\n\\t\\trateFactorSensitivity = rateFactorSensitivity_;\\n\\t\\tfeeBase = feeBase_;\\n\\t\\tfeeSensitivity = feeSensitivity_;\\n\\t\\trange = range_;\\n\\t}\\n\\n\\t/* @dev Calculates the per-block interest rate to offer an incoming swap based on the rateFactor stored in Rho.sol.\\n\\t * @param userPayingFixed : If the user is paying fixed in incoming swap\\n\\t * @param orderNotional : Notional order size of the incoming swap\\n\\t * @param lockedCollateralUnderlying : The amount of the protocol's liquidity that is locked at the time of the swap in underlying tokens\\n\\t * @param supplierLiquidityUnderlying : Total amount of the protocol's liquidity in underlying tokens\\n\\t */\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external override view returns (uint rate, int rateFactorNew) {\\n\\t\\trequire(supplierLiquidityUnderlying != 0, \\\"supplied liquidity 0\\\");\\n\\t\\tuint rfDelta = div(mul(rateFactorSensitivity, orderNotional), supplierLiquidityUnderlying);\\n\\t\\trateFactorNew = userPayingFixed ? add(rateFactorPrev, rfDelta) : sub(rateFactorPrev, rfDelta);\\n\\n\\t\\tint num = mul(rateFactorNew, range);\\n\\t\\tuint denom = sqrt(add(square(rateFactorNew), slopeFactor));\\n\\n\\t\\tuint baseRate = toZero(add(div(num, denom), yOffset)); // can not be negative\\n\\t\\tuint fee = getFee(lockedCollateralUnderlying, supplierLiquidityUnderlying);\\n\\n\\t\\t// base + yOffset +- fee\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\trate = add(baseRate, fee);\\n\\t\\t} else {\\n\\t\\t\\tif (baseRate > fee) {\\n\\t\\t\\t\\trate = sub(baseRate, fee);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trate = 0;\\n\\t\\t\\t\\t// if the rate is negative, don't push rate factor even lower\\n\\t\\t\\t\\trateFactorNew = rateFactorPrev;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// @dev Calculates the fee to add to the rate. fee = feeBase + feeSensitivity * locked / total\\n\\tfunction getFee(uint lockedCollateralUnderlying, uint supplierLiquidityUnderlying) public view returns (uint) {\\n\\t\\treturn add(feeBase, div(mul(feeSensitivity, lockedCollateralUnderlying), supplierLiquidityUnderlying));\\n\\t}\\n\\n    // ** Interest Rate Model Math Library **//\\n\\n    // Source: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n\\t// ** UINT SAFE MATH ** //\\n\\t// Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\\n\\n\\tfunction mul(uint a, uint b) internal pure returns (uint) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, \\\"SafeMath: Multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint a, uint b) internal pure returns (uint) {\\n        require(b > 0, \\\"SafeMath: Divide by zero\\\");\\n        uint c = a / b;\\n        return c;\\n    }\\n\\n    function add(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint a, uint b) pure internal returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n   \\t// ** INT SAFE MATH ** //\\n   \\t// Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SignedSafeMath.sol\\n\\tint constant private _INT_MIN = -2**255;\\n\\n    function div(int a, int b) internal pure returns (int) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int c = a / b;\\n\\n        return c;\\n    }\\n\\n    function mul(int a, int b) internal pure returns (int) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function add(int a, int b) internal pure returns (int) {\\n        int c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n   \\t// ** INT => UINT MATH ** //\\n\\n   \\t// Set negative ints to 0\\n    function toZero(int x) internal pure returns (uint) {\\n\\t\\treturn x > 0 ? uint(x) : 0;\\n\\t}\\n\\n\\tfunction square(int a) internal pure returns (uint) {\\n\\t\\treturn uint(mul(a, a));\\n\\t}\\n\\n\\t// ** UINT => INT MATH ** //\\n\\n\\tint constant private _INT_MAX = 2**255 - 1;\\n\\n    function add(int a, uint b) internal pure returns (int){\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int addition overflow detected\\\");\\n        return add(a, int(b));\\n    }\\n\\n\\tfunction mul(int a, uint b) internal pure returns (int) {\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int multiplication overflow detected\\\");\\n        return mul(a, int(b));\\n\\t}\\n\\n    function sub(int a, uint b) internal pure returns (int){\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int subtraction overflow detected\\\");\\n        return sub(a, int(b));\\n    }\\n\\n\\tfunction div(int a, uint b) internal pure returns (int) {\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int division overflow detected\\\");\\n        return div(a, int(b));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x3687e4d83502a5bb22609a621c023285c7a88fbde0317c3d2ad619352f013b09\"},\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"},\"contracts/test/MockInterestRateModel.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"../InterestRateModel.sol\\\";\\n\\ncontract MockInterestRateModel is InterestRateModelInterface {\\n\\tuint public mockRate = 1e10;\\n\\n\\tfunction setRate(uint rate_) public {\\n\\t\\tmockRate = rate_;\\n\\t}\\n\\n\\tfunction getSwapRate(int rateFactorPrev, bool userPayingFixed,  uint orderNotional, uint lockedCollateralUnderlying, uint supplierLiquidityUnderlying) external override view returns (uint rate, int rateFactorNew) {\\n\\t\\trateFactorPrev;\\n\\t\\tuserPayingFixed;\\n\\t\\torderNotional;\\n\\t\\tlockedCollateralUnderlying;\\n\\t\\tsupplierLiquidityUnderlying;\\n\\t\\treturn (mockRate, 1);\\n\\t}\\n}\\n\",\"keccak256\":\"0x51131fdad163db2b0b555d6a1408b64deffe3e57e2f94765dc962bbdfcd96a6c\"}},\"version\":1}"},"contracts/test/MockRho.sol:MockRho":{"abi":"[{\"inputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"contract CTokenInterface\",\"name\":\"cToken_\",\"type\":\"address\"},{\"internalType\":\"contract CompInterface\",\"name\":\"comp_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapMinDuration_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyMinDuration_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidityLimitCTokens_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplierLiquidityNew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedCollateralNew\",\"type\":\"uint256\"}],\"name\":\"Accrue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AdminRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexFinal\",\"type\":\"uint256\"}],\"name\":\"CloseSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"CompDelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CompTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OpenSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyValue\",\"type\":\"uint256\"}],\"name\":\"Remove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa\",\"type\":\"uint256\"}],\"name\":\"SetCollateralRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldModel\",\"type\":\"address\"}],\"name\":\"SetInterestRateModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"SetLiquidityLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"SetPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLOSE_GRACE_PERIOD_BLOCKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLOSE_PENALTY_PER_BLOCK_MANTISSA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_SWAP_NOTIONAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPPLY_MIN_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_MIN_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"_changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"_delegateComp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused_\",\"type\":\"bool\"}],\"name\":\"_pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa_\",\"type\":\"uint256\"}],\"name\":\"_setCollateralRequirements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"newModel\",\"type\":\"address\"}],\"name\":\"_setInterestRateModel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit_\",\"type\":\"uint256\"}],\"name\":\"_setLiquidityLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_transferComp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"advanceBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"advanceBlocksProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRatePaying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRateReceiving\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"benchmarkIndexStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"internalType\":\"contract CTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"comp\",\"outputs\":[{\"internalType\":\"contract CompInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBenchmarkIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExchangeRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accruedBlocks\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getLockedCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"parBlocksReceivingFixedNew\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"parBlocksPayingFixedNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"fixedRate\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getPayFixedInitCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"fixedRate\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getReceiveFixedInitCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accruedBlocks\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"floatRate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getSupplierLiquidity\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidityNew\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidity_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harnessAccrueInterest\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateralNew\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAccrualBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openPayFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openReceiveFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksPayingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksReceivingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateFactor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber_\",\"type\":\"uint256\"}],\"name\":\"setBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplierLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyAccounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"toCTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"toUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","bin":"610180604052670de0b6b3a7640000610160819052601481905561010052610bb861012052655af3107a40006101405260646015553480156200004157600080fd5b5060405162003bf238038062003bf2833981016040819052620000649162000220565b888888888888888888848610620000985760405162461bcd60e51b81526004016200008f90620002d4565b60405180910390fd5b600080546001600160a01b038b166001600160a01b03199091161790556001600160601b0319606089811b821660805288901b1660a052620000e3866001600160e01b03620001f116565b51600c55620000fb856001600160e01b03620001f116565b51600b5560c084905260e0839052601080546001600160a01b0319166001600160a01b0384811691909117909155601454600d556040805163aa5af0fd60e01b81529051620001b7928b169163aa5af0fd916004808301926020929190829003018186803b1580156200016d57600080fd5b505afa15801562000182573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001a89190620002bb565b6001600160e01b03620001f116565b516002556010805460ff60a01b19169055604080516020810190915281905260115550620003389f50505050505050505050505050505050565b620001fb6200020d565b50604080516020810190915290815290565b6040518060200160405280600081525090565b60008060008060008060008060006101208a8c0312156200023f578485fd5b89516200024c816200031f565b60208b01519099506200025f816200031f565b60408b015190985062000272816200031f565b8097505060608a0151955060808a0151945060a08a0151935060c08a0151925060e08a0151620002a2816200031f565b809250506101008a015190509295985092959850929598565b600060208284031215620002cd578081fd5b5051919050565b6020808252602b908201527f4d696e20666c6f61742072617465206d7573742062652062656c6f77206d617860408201526a20666c6f6174207261746560a81b606082015260800190565b6001600160a01b03811681146200033557600080fd5b50565b60805160601c60a05160601c60c05160e0516101005161012051610140516137f2620004006000398061186a5280611a755250806115205280611811528061183952508061123b52806125ab52508061104052806113625250806113f05280611444528061164052806117d1528061233b5280612486528061292c5280612a0c52508061068052806107db52806112d75250806108545280610d655280610e1e5280610f08528061139852806117225280611bd65280611f7552806121bd52506137f26000f3fe608060405234801561001057600080fd5b506004361061035d5760003560e01c80637a8c8d79116101d3578063b187bd2611610104578063e6aa216c116100a2578063f2b3abbd1161007c578063f2b3abbd14610653578063f3fdb15a14610666578063f851a4401461066e578063fa129ad1146106765761035d565b8063e6aa216c14610625578063eb84e7f21461062d578063f0b37021146106405761035d565b8063cda7ce0a116100de578063cda7ce0a146105d6578063cfba9e03146105e9578063e1c326391461060a578063e5505aed1461061d5761035d565b8063b187bd26146105a6578063be2e6564146105bb578063beff7b5b146105c35761035d565b806399c432ee11610171578063a05e60771161014b578063a05e607714610565578063a7a3d1161461056d578063a8c3c85014610580578063ac07293b146105935761035d565b806399c432ee146105425780639e887fba1461054a5780639fcbfcbf1461055d5761035d565b806388369f7e116101ad57806388369f7e146105225780638b72483c1461052a57806391a51a401461053257806398f1bc121461053a5761035d565b80637a8c8d791461050a5780637b386059146105125780637fb405f01461051a5761035d565b806344f94a19116102ad57806363d6d8211161024b5780636c979157116102255780636c979157146104d457806372163715146104e75780637366982c146104ef57806373b8a423146104f75761035d565b806363d6d821146104b157806369e527da146104b95780636c7f44da146104c15761035d565b80635568d1bb116102875780635568d1bb1461048657806355b6a697146104995780635675da9e146104a157806357e871e7146104a95761035d565b806344f94a19146104585780634cc822151461046b578063504ed5ca1461047e5761035d565b8063354030231161031a57806342cbb15c116102f457806342cbb15c14610406578063432a8e5d1461040e578063432ffe27146104215780634422581d146104435761035d565b806335403023146103e357806338d2bbc0146103f65780633f43955a146103fe5761035d565b8063109d0af8146103625780631152070c146103805780631f46eaae14610395578063234d999c146103aa57806331dc2fdf146103bd578063353dfc01146103d0575b600080fd5b61036a61067e565b6040516103779190612de6565b60405180910390f35b61039361038e366004612b6f565b6106a2565b005b61039d61075d565b6040516103779190612ec1565b6103936103b8366004612b28565b610763565b6103936103cb366004612c71565b610845565b6103936103de366004612b28565b610931565b6103936103f1366004612c71565b6109c4565b61039d610b9f565b61039d610ba5565b61039d610bab565b61039361041c366004612c71565b610bb2565b61043461042f366004612d35565b610c26565b6040516103779392919061374c565b61044b610d50565b6040516103779190613742565b61039d610466366004612c89565b610faa565b610393610479366004612c71565b610fc3565b61039d611239565b610393610494366004612b44565b61125d565b61039d611360565b61039d611384565b61039d61138a565b61039d611390565b61036a611396565b61044b6104cf366004612cbd565b6113ba565b6103936104e2366004612c71565b611431565b61039d61143c565b61039d611442565b610393610505366004612d8c565b611466565b61039d611506565b61039d61150c565b61039d611512565b61039d611518565b61039d61151e565b61039d611542565b61039d611548565b61039d61154e565b61044b610558366004612cbd565b611554565b61044b61157f565b61039d61159c565b61039361057b366004612c09565b6115a2565b61039d61058e366004612c71565b61196d565b61044b6105a1366004612d58565b611975565b6105ae611a63565b6040516103779190612e51565b61039d611a73565b61044b6105d1366004612d35565b611a97565b6104346105e4366004612b28565b611ac1565b6105fc6105f7366004612ba7565b611af0565b604051610377929190613763565b61039d610618366004612d8c565b611bb5565b61039d611bc3565b61044b611bc9565b6105ae61063b366004612c71565b611c2d565b61039d61064e366004612d8c565b611c42565b610393610661366004612b28565b611c50565b61036a611d0f565b61036a611d1e565b61039d611d2d565b7f000000000000000000000000000000000000000000000000000000000000000081565b6010546001600160a01b031633146106d55760405162461bcd60e51b81526004016106cc90613595565b60405180910390fd5b601060149054906101000a900460ff16151581151514156107085760405162461bcd60e51b81526004016106cc90612fde565b7f140eb9f8b591138e129e4caf389c92df4f0545b902523eee9e63153ecdb2026e816040516107379190612e51565b60405180910390a160108054911515600160a01b0260ff60a01b19909216919091179055565b60015481565b6010546001600160a01b0316331461078d5760405162461bcd60e51b81526004016106cc90612eed565b7fa5afd48b94a3b05f17f5a852e09af04691e3a21d9dcff1c6a4c217f2dc5724ed816040516107bc9190612de6565b60405180910390a16040516317066a5760e21b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690635c19a95c90610810908490600401612de6565b600060405180830381600087803b15801561082a57600080fd5b505af115801561083e573d6000803e3d6000fd5b5050505050565b61084e81611431565b600060607f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168360405160240161088d9190612ec1565b60408051601f198184030181529181526020820180516001600160e01b0316636c97915760e01b179052516108c29190612dad565b6000604051808303816000865af19150503d80600081146108ff576040519150601f19603f3d011682016040523d82523d6000602084013e610904565b606091505b50909250905060018215151461092c5760405162461bcd60e51b81526004016106cc90613516565b505050565b6010546001600160a01b0316331461095b5760405162461bcd60e51b81526004016106cc906134b2565b6010546040517f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f9161099a916001600160a01b03909116908490612dfa565b60405180910390a1601080546001600160a01b0319166001600160a01b0392909216919091179055565b6109cc612ab1565b5060408051602081019091528181526109e3612ab1565b6040805160208101909152600e5481526109fd9083611d33565b60408051602081019091526011548152909150610a1b908290611d61565b610a375760405162461bcd60e51b81526004016106cc90613642565b601054600160a01b900460ff1615610a615760405162461bcd60e51b81526004016106cc9061348b565b610a69612ab1565b610a71611bc9565b9050610a7c81611d68565b50610a85612ab1565b5033600090815260126020908152604091829020825191820190925290548152610aad612ab1565b8151610ac85750604080516020810190915260008152610af7565b33600090815260126020526040902060020154600d54610af390610aed908590611f1a565b82611f3b565b9150505b610aff612ab1565b610b098287611d33565b805160405191925033917f9d624b01705090e0c402c84f2bdef9c498399a009cee9a4e08ab004bae44712191610b41918b9190613772565b60405180910390a233600090815260126020526040902081519055610b64610bab565b3360008181526012602052604090206001810192909255600d546002909201919091558551600e55610b969087611f5c565b50505050505050565b60045481565b60085481565b6015545b90565b6010546001600160a01b03163314610bdc5760405162461bcd60e51b81526004016106cc90613071565b7f3a954648dc1ef6ec8f27ab3e4e360b29cabcdc89a7b6af23a7d33b186f223c5381604051610c0b9190612ec1565b60405180910390a16040805160208101909152819052601155565b610c2e612ab1565b600080610c48600754610c4387600354612024565b612069565b9150610c5c600854610c4387600554612024565b90506000610c81610c6c8361208e565b6040805160208101909152600c5481526120a2565b90506000610ca6610c918561208e565b6040805160208101909152600b5481526120a2565b90506000610ccb610cb68661208e565b604080516020810190915260095481526120a2565b90506000610cf0610cdb8661208e565b6040805160208101909152600a5481526120a2565b90506000610cfe83866120ca565b90506000610d0c83866120ca565b905081811115610d3057610d29610d2382846120ef565b8b611a97565b9850610d43565b6040518060200160405280600081525098505b5050505050509250925092565b610d58612ab1565b610d60612ab1565b610df97f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663aa5af0fd6040518163ffffffff1660e01b815260040160206040518083038186803b158015610dbc57600080fd5b505afa158015610dd0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610df49190612cfa565b612117565b8051909150610e1a5760405162461bcd60e51b81526004016106cc9061300c565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636c540baf6040518163ffffffff1660e01b815260040160206040518083038186803b158015610e7557600080fd5b505afa158015610e89573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ead9190612cfa565b905080610eb8610bab565b1015610ed65760405162461bcd60e51b81526004016106cc90613236565b6000610ee9610ee3610bab565b836120ef565b905080610efb57829350505050610baf565b610f03612ab1565b610f5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f8f9da286040518163ffffffff1660e01b815260040160206040518083038186803b158015610dbc57600080fd5b9050610f69612ab1565b610f738284611f1a565b9050610f9e85610f99836014604051806020016040529081600082015481525050611d33565b612131565b95505050505050610baf565b6000610fba8360000151836120a2565b90505b92915050565b610fcb612ab1565b506040805160208101909152818152610fe2612ac4565b5033600090815260126020908152604091829020825160808101845281546060820181815282526001830154938201939093526002909101549281019290925261103e5760405162461bcd60e51b81526004016106cc90612f9d565b7f0000000000000000000000000000000000000000000000000000000000000000816020015161106c610bab565b03101561108b5760405162461bcd60e51b81526004016106cc90612f50565b611093612ab1565b61109b611bc9565b90506110a5612ab1565b6110ae82611d68565b90506110b8612ab1565b6110d56110cb8560000151600d54611f1a565b8560400151611f3b565b85519091506110e2578094505b6110ec8582612170565b6111085760405162461bcd60e51b81526004016106cc906130b5565b611110612ab1565b6040805160208101909152600e54815261112a9084612178565b90506111368682612170565b6111525760405162461bcd60e51b81526004016106cc906135c5565b6040805160208101909152600e54815261116d908790612170565b6111895760405162461bcd60e51b81526004016106cc90613440565b611191612ab1565b61119b8388612178565b805160405191925033917fda84cdf19e8ef1de60c2e7ecedcb3b440ae5dcaa1ace44fd3a9111d824356e65916111d3918c9190613772565b60405180910390a26111e3610bab565b336000908152601260209081526040918290206001810193909355600d546002840155835190925580519182019052600e5481526112219088612178565b51600e5561122f338861219d565b5050505050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b6010546001600160a01b031633146112875760405162461bcd60e51b81526004016106cc90613305565b7f81ff49596187b8a1171fd1c1f47390d63b10c52113fecc4a4eff1ae1feeaee7482826040516112b8929190612e38565b60405180910390a160405163a9059cbb60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb9061130e9085908590600401612e38565b602060405180830381600087803b15801561132857600080fd5b505af115801561133c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061092c9190612b8b565b7f000000000000000000000000000000000000000000000000000000000000000081565b60075481565b60155481565b600c5481565b7f000000000000000000000000000000000000000000000000000000000000000081565b6113c2612ab1565b6113ca612ab1565b6040805160208101909152600b5481526113e49086612178565b9050600061141b6114157f000000000000000000000000000000000000000000000000000000000000000087612024565b836120a2565b90506114278185611a97565b9695505050505050565b601580549091019055565b60115481565b7f000000000000000000000000000000000000000000000000000000000000000081565b6010546001600160a01b031633146114905760405162461bcd60e51b81526004016106cc90613387565b8082106114af5760405162461bcd60e51b81526004016106cc9061333c565b7f15870c625f3ba69feb270c10e4a11ff6f6c36d08b25bf69e1efae181f337b12082826040516114e0929190613772565b60405180910390a16114f182612117565b51600c556114fe81612117565b51600b555050565b600b5481565b600e5481565b60095481565b600a5481565b7f000000000000000000000000000000000000000000000000000000000000000081565b60055481565b600d5481565b60035481565b61155c612ab1565b611564612ab1565b6040805160208101909152600c5481526113e4908690612178565b611587612ab1565b611597611592611bc9565b611d68565b905090565b600f5481565b6115aa612ab1565b6115b2611bc9565b90506115bd81611d68565b506000888888888888886040516020016115dd9796959493929190612e86565b60408051601f1981840301815291815281516020928301206000818152601390935291205490915060ff1615156001146116295760405162461bcd60e51b81526004016106cc90613189565b600061163c611636610bab565b896120ef565b90507f000000000000000000000000000000000000000000000000000000000000000081101561167e5760405162461bcd60e51b81526004016106cc9061325d565b611686612ab1565b604080516020810190915260025481526116a8906116a38c612117565b612260565b90506116b2612ab1565b5060408051602081019091528681526116c9612ab1565b6116d28a612117565b90506116dc612ab1565b8d156116f7576116f08585848d878c612293565b9050611708565b6117058585848d878c6123f2565b90505b6040516370a0823160e01b81526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906370a0823190611757903090600401612de6565b602060405180830381600087803b15801561177157600080fd5b505af1158015611785573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117a99190612cfa565b905080826000015111156117c95760405180602001604052808281525091505b60006117f5877f00000000000000000000000000000000000000000000000000000000000000006120ef565b90506117ff612ab1565b506040805160208101909152600081527f00000000000000000000000000000000000000000000000000000000000000008211156118e6577f00000000000000000000000000000000000000000000000000000000000000008203611862612ab1565b61189461188e7f0000000000000000000000000000000000000000000000000000000000000000612117565b83611f1a565b8051601454919250106118b657604080516020810190915260145481526118b8565b805b905060405180602001604052806118d38860000151846120a2565b905292506118e18684612178565b955050505b835181516002546040516001600160a01b038f16938d937f93eb2111fe97d82145065cf28523f16424bbf533e378b8ae2f5a63eb7bec23ec9361192893613780565b60405180910390a36000898152601360205260409020805460ff191690556119508b8561219d565b61195a338261219d565b5050505050505050505050505050505050565b601555600090565b61197d612ab1565b600061198b600454856120a2565b9050600061199b600654866120a2565b905060006119ca876119c5600554600a6040518060200160405290816000820154815250506120a2565b612024565b905060006119f4886119c560035460096040518060200160405290816000820154815250506120a2565b90506119fe612ab1565b611a11611a0b83866120ca565b88611a97565b9050611a1b612ab1565b611a2e611a2885886120ca565b89611a97565b6040805160208101909152600e548152909150611a5590611a4f9084611d33565b82612527565b9a9950505050505050505050565b601054600160a01b900460ff1681565b7f000000000000000000000000000000000000000000000000000000000000000081565b611a9f612ab1565b6000611aab848461255e565b6040805160208101909152908152949350505050565b601260209081526000918252604091829020825191820190925281548152600182015460029092015490919083565b611af8612ab1565b60008054600f54829182916001600160a01b03909116906327fc0024908b8b611b218c8b610faa565b611b2b8c8c610faa565b6040518663ffffffff1660e01b8152600401611b4b959493929190612eca565b604080518083038186803b158015611b6257600080fd5b505afa158015611b76573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b9a9190612d12565b91509150611ba782612117565b999098509650505050505050565b6000610fba6001848461257c565b60025481565b611bd1612ab1565b6115977f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663182df0f56040518163ffffffff1660e01b815260040160206040518083038186803b158015610dbc57600080fd5b60136020526000908152604090205460ff1681565b6000610fba6000848461257c565b6010546001600160a01b03163314611c7a5760405162461bcd60e51b81526004016106cc906131ee565b6000546001600160a01b0382811691161415611ca85760405162461bcd60e51b81526004016106cc906131b7565b6000546040517faa0318754c43eb4a32620f6f8887531662fb2f7f5deb5ab2b318f63a0c9f076291611ce59184916001600160a01b031690612dfa565b60405180910390a1600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b031681565b6010546001600160a01b031681565b60065481565b611d3b612ab1565b6040518060200160405280611d58856000015185600001516120ca565b90529392505050565b5190511090565b611d70612ab1565b600154611d7b610bab565b1015611d995760405162461bcd60e51b81526004016106cc906136b5565b6000600154611da6610bab565b039050611db1612ab1565b600080611dbe8487610c26565b9250925092508360001415611dd95782945050505050611f15565b611de1612ab1565b611de9610d50565b9050611df3612ab1565b60408051602081019091526002548152611e0e908390612260565b9050611e18612ab1565b60408051602081019091526014548152611e33908390612178565b9050611e3d612ab1565b611e4888838c611975565b600d5481519192509015611e7d57611e7a611e65600d5484612871565b6040805160208101909152600e548152612881565b90505b6000611e8b600454866120a2565b90506000611e9b600654876120a2565b600889905560078a90558451600e55600d8490556004839055600681905587516002559050611ec8610bab565b60015583518a516040517f2335845cb850fcf8fbf00f6231fabd745068faf756278e33bb45716d4cf934f392611eff929091613772565b60405180910390a1509799505050505050505050505b919050565b611f22612ab1565b6040518060200160405280611d58856000015185612024565b611f43612ab1565b6040518060200160405280611d5885600001518561288d565b80516040516323b872dd60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016916323b872dd91611fad918691309190600401612e14565b602060405180830381600087803b158015611fc757600080fd5b505af1158015611fdb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fff9190612b8b565b15156001146120205760405162461bcd60e51b81526004016106cc90612f24565b5050565b6000821580612031575081155b1561203e57506000610fbd565b8282028284828161204b57fe5b0414610fba5760405162461bcd60e51b81526004016106cc90613125565b600081830380841215610fba5760405162461bcd60e51b81526004016106cc90613043565b600080821361209e576000610fbd565b5090565b6000670de0b6b3a76400006120bb848460000151612024565b816120c257fe5b049392505050565b600082820183811015610fba5760405162461bcd60e51b81526004016106cc906133d3565b6000828211156121115760405162461bcd60e51b81526004016106cc90613686565b50900390565b61211f612ab1565b50604080516020810190915290815290565b612139612ab1565b6040518060200160405280670de0b6b3a764000061215f86600001518660000151612024565b8161216657fe5b0490529392505050565b519051111590565b612180612ab1565b6040518060200160405280611d58856000015185600001516120ef565b80511561202057805160405163a9059cbb60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169163a9059cbb916121f2918691600401612e38565b602060405180830381600087803b15801561220c57600080fd5b505af1158015612220573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122449190612b8b565b6120205760405162461bcd60e51b81526004016106cc906134e9565b612268612ab1565b6040518060200160405280611d5861228c8660000151670de0b6b3a7640000612024565b855161288d565b61229b612ab1565b60006122a9600354866128b7565b905060006122c26004546122bd888b6120a2565b6128b7565b90506122cc612ab1565b826122e2576122db6000612117565b9050612329565b6122ea612ab1565b604080516020810190915260095481526003546123199161230a91611f1a565b6123148b8b611f1a565b612527565b90506123258185611f3b565b9150505b600061236460075461235f8a6119c58f7f00000000000000000000000000000000000000000000000000000000000000006120ef565b6128d2565b905061236e612ab1565b612384611a0b61237e8b8f612024565b8c6120a2565b905061238e612ab1565b6123ba611a288b6123b58f6014604051806020016040529081600082015481525050612178565b6120a2565b90506123cf6123c98a83611d33565b83612527565b600396909655505060049290925560079190915551600955979650505050505050565b6123fa612ab1565b6000612408600554866128b7565b9050600061241c6006546122bd888b6120a2565b9050612426612ab1565b8261243c576124356000612117565b9050612474565b612444612ab1565b6040805160208101909152600a5481526005546124649161230a91611f1a565b90506124708184611f3b565b9150505b60006124aa60085461235f8a6119c58f7f00000000000000000000000000000000000000000000000000000000000000006120ef565b90506124b4612ab1565b6124c4611a0b61237e8b8f612024565b90506124ce612ab1565b6124f5611a288b6123b58f6014604051806020016040529081600082015481525050612178565b9050612504611a4f8a84611d33565b600596909655505060069290925560089190915551600a55979650505050505050565b61252f612ab1565b825182511061254d5750604080516020810190915260008152610fbd565b6125578383612178565b9050610fbd565b6000610fba61257584670de0b6b3a7640000612024565b835161288d565b601054600090600160a01b900460ff16156125a95760405162461bcd60e51b81526004016106cc9061348b565b7f00000000000000000000000000000000000000000000000000000000000000008310156125e95760405162461bcd60e51b81526004016106cc9061354d565b6125f1612ab1565b6125f9611bc9565b9050612603612ab1565b61260c82611d68565b9050612616612ab1565b506040805160208082018352600e5482528251908101909252601154825290612640908290611d61565b61265c5760405162461bcd60e51b81526004016106cc906133fe565b612664612ab1565b60006126738989868689611af0565b9150915061267f612ab1565b89156126fd5782518810156126a65760405162461bcd60e51b81526004016106cc906136ec565b6126ae612ab1565b6126c2866126bd868d8b6113ba565b611d33565b90506126ce8186612170565b6126ea5760405162461bcd60e51b81526004016106cc9061360d565b6126f58a85896128f7565b91505061276c565b825188111561271e5760405162461bcd60e51b81526004016106cc906132b3565b612726612ab1565b612735866126bd868d8b611554565b90506127418186612170565b61275d5760405162461bcd60e51b81526004016106cc9061360d565b6127688a85896129d7565b9150505b6002548a90612779610bab565b8551845160405161279495949392918f913390602001612e86565b60408051601f1981840301815291815281516020928301206000818152601390935291205490975060ff16156127dc5760405162461bcd60e51b81526004016106cc9061328b565b336001600160a01b0316877f9bd76dee09f83be107bfb98bb838387d6be9992388da0de713711424c3473cd68c600260000154612817610bab565b88600001518f886000015160405161283496959493929190612e5c565b60405180910390a36000878152601360205260409020805460ff19166001179055600f8290556128643382611f5c565b5050505050509392505050565b6000610fba838360000151612024565b6000610fba8383600001515b60008082116128ae5760405162461bcd60e51b81526004016106cc906130fd565b8183816120c257fe5b60008282106128c857506000610fbd565b61255783836120ef565b600082820180841315610fba5760405162461bcd60e51b81526004016106cc9061315c565b6128ff612ab1565b600061290d600354866120ca565b9050600061291d600454876120ca565b9050600061295160075461235f7f00000000000000000000000000000000000000000000000000000000000000008a612024565b905061295b612ab1565b604080516020810190915260095481526003546129789190611f1a565b9050612982612ab1565b61298c888a611f1a565b9050612996612ab1565b6129a96129a38484611d33565b87611f3b565b90506129b6898b8a611554565b60049590955560039590955550509151600955600791909155949350505050565b6129df612ab1565b60006129ed600554866120ca565b905060006129fd600654876120ca565b90506000612a3160085461235f7f00000000000000000000000000000000000000000000000000000000000000008a612024565b9050612a3b612ab1565b6040805160208101909152600a548152600554612a589190611f1a565b9050612a62612ab1565b612a6c888a611f1a565b9050612a76612ab1565b612a836129a38484611d33565b9050612a90898b8a6113ba565b60069590955560059590955550509151600a55600891909155949350505050565b6040518060200160405280600081525090565b6040518060600160405280612ad7612ab1565b815260200160008152602001600081525090565b600060208284031215612afc578081fd5b6040516020810181811067ffffffffffffffff82111715612b1b578283fd5b6040529135825250919050565b600060208284031215612b39578081fd5b8135610fba81613796565b60008060408385031215612b56578081fd5b8235612b6181613796565b946020939093013593505050565b600060208284031215612b80578081fd5b8135610fba816137ae565b600060208284031215612b9c578081fd5b8151610fba816137ae565b600080600080600060a08688031215612bbe578081fd5b8535612bc9816137ae565b945060208601359350612bdf8760408801612aeb565b9250612bee8760608801612aeb565b9150612bfd8760808801612aeb565b90509295509295909350565b600080600080600080600060e0888a031215612c23578182fd5b8735612c2e816137ae565b96506020880135955060408801359450606088013593506080880135925060a0880135915060c0880135612c6181613796565b8091505092959891949750929550565b600060208284031215612c82578081fd5b5035919050565b60008060408385031215612c9b578182fd5b612ca58484612aeb565b9150612cb48460208501612aeb565b90509250929050565b600080600060608486031215612cd1578283fd5b612cdb8585612aeb565b925060208401359150612cf18560408601612aeb565b90509250925092565b600060208284031215612d0b578081fd5b5051919050565b60008060408385031215612d24578081fd5b505080516020909101519092909150565b60008060408385031215612d47578182fd5b82359150612cb48460208501612aeb565b600080600060608486031215612d6c578081fd5b83359250612d7d8560208601612aeb565b9150612cf18560408601612aeb565b60008060408385031215612d9e578182fd5b50508035926020909101359150565b60008251815b81811015612dcd5760208186018101518583015201612db3565b81811115612ddb5782828501525b509190910192915050565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b03929092168252602082015260400190565b901515815260200190565b9515158652602086019490945260408501929092526060840152608083015260a082015260c00190565b9615158752602087019590955260408601939093526060850191909152608084015260a08301526001600160a01b031660c082015260e00190565b90815260200190565b948552921515602085015260408401919091526060830152608082015260a00190565b6020808252601e908201527f4d7573742062652061646d696e20746f2064656c656761746520636f6d700000604082015260600190565b602080825260129082015271151c985b9cd9995c88125b8811985a5b195960721b604082015260600190565b6020808252602d908201527f4c6971756964697479206d75737420626520737570706c6965642061206d696e60408201526c34b6bab690323ab930ba34b7b760991b606082015260800190565b60208082526021908201527f4d7573742077697468647261772066726f6d20616374697665206163636f756e6040820152601d60fa1b606082015260800190565b602080825260149082015273135d5cdd0818da185b99d9481a5cd4185d5cd95960621b604082015260600190565b60208082526017908201527f42656e63686d61726b20696e646578206973207a65726f000000000000000000604082015260600190565b602080825260149082015273696e74202d2075696e7420756e646572666c6f7760601b604082015260600190565b60208082526024908201527f4d7573742062652061646d696e20746f20736574206c6971697564697479206c6040820152631a5b5a5d60e21b606082015260800190565b60208082526028908201527f547279696e6720746f2072656d6f7665206d6f7265207468616e206163636f756040820152676e742076616c756560c01b606082015260800190565b6020808252600e908201526d646976696465206279207a65726f60901b604082015260600190565b60208082526017908201527f6d756c7469706c69636174696f6e206f766572666c6f77000000000000000000604082015260600190565b602080825260139082015272696e74202b2075696e74206f766572666c6f7760681b604082015260600190565b602080825260149082015273139bc81858dd1a5d99481cddd85c08199bdd5b9960621b604082015260600190565b60208082526017908201527f526573657474696e6720746f2073616d65206d6f64656c000000000000000000604082015260600190565b60208082526028908201527f4d7573742062652061646d696e20746f2073657420696e7465726573742072616040820152671d19481b5bd9195b60c21b606082015260800190565b6020808252600d908201526c426e2064656372656173696e6760981b604082015260600190565b60208082526014908201527305072656d617475726520636c6f736520737761760641b604082015260600190565b6020808252600e908201526d04475706c696361746520737761760941b604082015260600190565b60208082526032908201527f54686520666978656420726174652052686f20776f756c64207061792069732060408201527118995b1bddc81d5cd95c89dcc81b1a5b5a5d60721b606082015260800190565b6020808252601e908201527f4d7573742062652061646d696e20746f207472616e7366657220636f6d700000604082015260600190565b6020808252602b908201527f4d696e20666c6f61742072617465206d7573742062652062656c6f77206d617860408201526a20666c6f6174207261746560a81b606082015260800190565b6020808252602c908201527f4d7573742062652061646d696e20746f2073657420636f6c6c61746572616c2060408201526b726571756972656d656e747360a01b606082015260800190565b6020808252601190820152706164646974696f6e206f766572666c6f7760781b604082015260600190565b60208082526022908201527f4f70656e207061757365642c2061626f7665206c6971756964697479206c696d6040820152611a5d60f21b606082015260800190565b6020808252602b908201527f52656d6f76696e67206d6f7265207468616e20746f74616c20737570706c696560408201526a72206c697175696469747960a81b606082015260800190565b6020808252600d908201526c13585c9ad95d081c185d5cd959609a1b604082015260600190565b6020808252601d908201527f4d7573742062652061646d696e20746f206368616e67652061646d696e000000604082015260600190565b602080825260139082015272151c985b9cd9995c8813dd5d0819985a5b1959606a1b604082015260600190565b60208082526019908201527f416476616e636520626c6f636b73206469646e7420776f726b00000000000000604082015260600190565b60208082526028908201527f53776170206e6f74696f6e616c20616d6f756e74206d75737420657863656564604082015267206d696e696d756d60c01b606082015260800190565b6020808252601690820152754d7573742062652061646d696e20746f20706175736560501b604082015260600190565b60208082526028908201527f52656d6f76696e67206d6f7265206c6971756964697479207468616e206973206040820152671d5b9b1bd8dad95960c21b606082015260800190565b6020808252818101527f496e73756666696369656e742070726f746f636f6c20636f6c6c61746572616c604082015260600190565b60208082526024908201527f537570706c79207061757365642c2061626f7665206c6971756964697479206c6040820152631a5b5a5d60e21b606082015260800190565b6020808252601590820152747375627472616374696f6e20756e646572666c6f7760581b604082015260600190565b60208082526017908201527f426c6f636b206e756d6265722064656372656173696e67000000000000000000604082015260600190565b60208082526036908201527f54686520666978656420726174652052686f20776f756c642072656365697665604082015275081a5cc818589bdd99481d5cd95c89dcc81b1a5b5a5d60521b606082015260800190565b9051815260200190565b925183526020830191909152604082015260600190565b91518252602082015260400190565b918252602082015260400190565b9283526020830191909152604082015260600190565b6001600160a01b03811681146137ab57600080fd5b50565b80151581146137ab57600080fdfea2646970667358221220614b4045ac250ebe370787cffacddc0e95eb5797d0533f3fcdd2eb3af70949db64736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"contract CTokenInterface\",\"name\":\"cToken_\",\"type\":\"address\"},{\"internalType\":\"contract CompInterface\",\"name\":\"comp_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapMinDuration_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyMinDuration_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidityLimitCTokens_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplierLiquidityNew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedCollateralNew\",\"type\":\"uint256\"}],\"name\":\"Accrue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AdminRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexFinal\",\"type\":\"uint256\"}],\"name\":\"CloseSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"CompDelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CompTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OpenSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyValue\",\"type\":\"uint256\"}],\"name\":\"Remove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa\",\"type\":\"uint256\"}],\"name\":\"SetCollateralRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldModel\",\"type\":\"address\"}],\"name\":\"SetInterestRateModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"SetLiquidityLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"SetPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLOSE_GRACE_PERIOD_BLOCKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLOSE_PENALTY_PER_BLOCK_MANTISSA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_SWAP_NOTIONAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPPLY_MIN_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_MIN_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"_changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"_delegateComp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused_\",\"type\":\"bool\"}],\"name\":\"_pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minFloatRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFloatRateMantissa_\",\"type\":\"uint256\"}],\"name\":\"_setCollateralRequirements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"newModel\",\"type\":\"address\"}],\"name\":\"_setInterestRateModel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit_\",\"type\":\"uint256\"}],\"name\":\"_setLiquidityLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_transferComp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"advanceBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"advanceBlocksProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRatePaying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgFixedRateReceiving\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"benchmarkIndexStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"internalType\":\"contract CTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"benchmarkIndexInit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"comp\",\"outputs\":[{\"internalType\":\"contract CompInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBenchmarkIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExchangeRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accruedBlocks\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getLockedCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"parBlocksReceivingFixedNew\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"parBlocksPayingFixedNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"fixedRate\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getPayFixedInitCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"fixedRate\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getReceiveFixedInitCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accruedBlocks\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"floatRate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getSupplierLiquidity\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidityNew\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidity_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harnessAccrueInterest\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateralNew\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAccrualBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFloatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalPayingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalReceivingFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openPayFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFixedRateMantissa\",\"type\":\"uint256\"}],\"name\":\"openReceiveFixedSwap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksPayingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parBlocksReceivingFixed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateFactor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"removeCTokenAmount\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber_\",\"type\":\"uint256\"}],\"name\":\"setBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplierLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenSupplyAmount\",\"type\":\"uint256\"}],\"name\":\"supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyAccounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"toCTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"name\":\"toUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{\"_setInterestRateModel(address)\":{\"notice\":\"ADMIN FUNCTIONS *\"}}}},\"settings\":{\"compilationTarget\":{\"contracts/test/MockRho.sol\":\"MockRho\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Math.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\n/* @dev A safe math lib for Rho data types. \\n   Note: always returns type of left side param */\\ncontract Math is Types {\\n\\n\\tuint constant EXP_SCALE = 1e18;\\n    Exp ONE_EXP = Exp({mantissa: EXP_SCALE});\\n\\n    function _toExp(uint num) pure internal returns (Exp memory) {\\n    \\treturn Exp({mantissa: num});\\n    }\\n\\n    function _toUint(int a) pure internal returns (uint) {\\n        return a > 0 ? uint(a) : 0;\\n    }\\n\\n    function _lt(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val < b.val;\\n    }\\n\\n    function _lte(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val <= b.val;\\n    }\\n\\n    function _add(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _add(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _add(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _add(a.val, b.val)});\\n    }\\n\\n    function _add(uint a, uint b) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function _sub(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _sub(a.mantissa, b.mantissa)});\\n    }\\n\\n    function _subToZero(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        if (b.val >= a.val) {\\n            return CTokenAmount({val: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(uint a, uint b) pure internal returns (uint) {\\n        if (b >= a) {\\n            return 0;\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _subToZero(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        if (b.mantissa >= a.mantissa) {\\n            return Exp({mantissa: 0});\\n        } else {\\n            return _sub(a,b);\\n        }\\n    }\\n\\n    function _sub(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _sub(a.val, b.val)});\\n    }\\n\\n    function _sub(uint a, uint b) pure internal returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function _sub(int a, uint b) pure internal returns (int) {\\n        int c = a - int(b);\\n        require(a >= c, \\\"int - uint underflow\\\");\\n        return c;\\n    }\\n\\n    function _add(int a, uint b) pure internal returns (int) {\\n        int c = a + int(b);\\n        require(a <= c, \\\"int + uint overflow\\\");\\n        return c;\\n    }\\n\\n    function _mul(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _mul(a, b.val);\\n    }\\n\\n    function _mul(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _mul(a.val, b)});\\n    }\\n\\n    function _mul(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b.mantissa) / EXP_SCALE});\\n    }\\n\\n    function _mul(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _mul(a.mantissa, b)});\\n    }\\n\\n    function _mul(uint a, Exp memory b) pure internal returns (uint) {\\n        return _mul(a, b.mantissa) / EXP_SCALE;\\n    }\\n\\n    function _mul(uint a, uint b) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function _div(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return _div(a, b.val);\\n    }\\n\\n    function _div(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: _div(a.val, b)});\\n    }\\n\\n    function _div(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(_mul(a.mantissa, EXP_SCALE), b.mantissa)});\\n    }\\n\\n    function _div(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: _div(a.mantissa, b)});\\n    }\\n\\n    function _div(uint a, Exp memory b) pure internal returns (uint) {\\n        return _div(_mul(a, EXP_SCALE), b.mantissa);\\n    }\\n\\n    function _div(uint a, uint b) pure internal returns (uint) {\\n        require(b > 0, \\\"divide by zero\\\");\\n        return a / b;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x8c6200920feaf6aa32f936d0daf59a94bc84b9b5808c425db8b1eba60bd65e06\"},\"contracts/Rho.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Math.sol\\\";\\nimport {RhoInterface, CTokenInterface, CompInterface, InterestRateModelInterface} from \\\"./RhoInterfaces.sol\\\";\\n\\n/* @dev:\\n * CTokens are used as collateral. \\\"Underlying\\\" in Rho refers to the collateral CToken's underlying token.\\n * An Exp is a data type with 18 decimals, used for scaling up and precise calculations */\\ncontract Rho is RhoInterface, Math {\\n\\n\\tCTokenInterface public immutable cToken;\\n\\tCompInterface public immutable comp;\\n\\n\\tuint public immutable SWAP_MIN_DURATION;\\n\\tuint public immutable SUPPLY_MIN_DURATION;\\n\\tuint public immutable MIN_SWAP_NOTIONAL = 1e18;\\n\\tuint public immutable CLOSE_GRACE_PERIOD_BLOCKS = 3000; // ~12.5 hrs\\n\\tuint public immutable CLOSE_PENALTY_PER_BLOCK_MANTISSA = 1e14;// 1% (1e16) every 25 min (100 blocks)\\n\\n\\tconstructor (\\n\\t\\tInterestRateModelInterface interestRateModel_,\\n\\t\\tCTokenInterface cToken_,\\n\\t\\tCompInterface comp_,\\n\\t\\tuint minFloatRateMantissa_,\\n\\t\\tuint maxFloatRateMantissa_,\\n\\t\\tuint swapMinDuration_,\\n\\t\\tuint supplyMinDuration_,\\n\\t\\taddress admin_,\\n\\t\\tuint liquidityLimitCTokens_\\n\\t) public {\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\tinterestRateModel = interestRateModel_;\\n\\t\\tcToken = cToken_;\\n\\t\\tcomp = comp_;\\n\\t\\tminFloatRate = _toExp(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = _toExp(maxFloatRateMantissa_);\\n\\t\\tSWAP_MIN_DURATION = swapMinDuration_;\\n\\t\\tSUPPLY_MIN_DURATION = supplyMinDuration_;\\n\\t\\tadmin = admin_;\\n\\n\\t\\tsupplyIndex = ONE_EXP.mantissa;\\n\\t\\tbenchmarkIndexStored = _toExp(cToken_.borrowIndex());\\n\\t\\tisPaused = false;\\n\\t\\tliquidityLimit = CTokenAmount({val:liquidityLimitCTokens_});\\n\\t}\\n\\n\\t/* @dev Supplies liquidity to the protocol. Become the counterparty for all swap traders, in return for fees.\\n\\t * @param cTokenSupplyAmount Amount to supply, in CTokens.\\n\\t */\\n\\tfunction supply(uint cTokenSupplyAmount) public override {\\n\\t\\tCTokenAmount memory supplyAmount = CTokenAmount({val: cTokenSupplyAmount});\\n\\t\\tCTokenAmount memory supplierLiquidityNew = _add(supplierLiquidity, supplyAmount);\\n\\t\\t\\n\\t\\trequire(_lt(supplierLiquidityNew, liquidityLimit), \\\"Supply paused, above liquidity limit\\\");\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory prevSupply = supplyAccounts[msg.sender].amount;\\n\\n\\t\\tCTokenAmount memory truedUpPrevSupply;\\n\\t\\tif (prevSupply.val == 0) {\\n\\t\\t\\ttruedUpPrevSupply = CTokenAmount({val: 0});\\n\\t\\t} else {\\n\\t\\t\\tuint prevIndex = supplyAccounts[msg.sender].index;\\n\\t\\t\\ttruedUpPrevSupply = _div(_mul(prevSupply, supplyIndex), prevIndex);\\n\\t\\t}\\n\\n\\t\\tCTokenAmount memory newSupplyAmount = _add(truedUpPrevSupply, supplyAmount);\\n\\n\\t\\temit Supply(msg.sender, cTokenSupplyAmount, newSupplyAmount.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].amount = newSupplyAmount;\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\n\\t\\ttransferIn(msg.sender, supplyAmount);\\n\\t}\\n\\n\\t/* @dev Remove liquidity from protocol. Can only perform after a waiting period from supplying, to prevent interest rate manipulation\\n\\t * @param removeCTokenAmount Amount of CTokens to remove. 0 removes all CTokens.\\n\\t */\\n\\tfunction remove(uint removeCTokenAmount) public override {\\n\\t\\tCTokenAmount memory removeAmount = CTokenAmount({val: removeCTokenAmount});\\n\\t\\tSupplyAccount memory account = supplyAccounts[msg.sender];\\n\\t\\trequire(account.amount.val > 0, \\\"Must withdraw from active account\\\");\\n\\t\\trequire(getBlockNumber() - account.lastBlock >= SUPPLY_MIN_DURATION, \\\"Liquidity must be supplied a minimum duration\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory truedUpAccountValue = _div(_mul(account.amount, supplyIndex), account.index);\\n\\n\\t\\t// Remove all liquidity\\n\\t\\tif (removeAmount.val == 0) {\\n\\t\\t\\tremoveAmount = truedUpAccountValue;\\n\\t\\t}\\n\\t\\trequire(_lte(removeAmount, truedUpAccountValue), \\\"Trying to remove more than account value\\\");\\n\\t\\tCTokenAmount memory unlockedCollateral = _sub(supplierLiquidity, lockedCollateral);\\n\\t\\t\\n\\t\\trequire(_lte(removeAmount, unlockedCollateral), \\\"Removing more liquidity than is unlocked\\\");\\n\\t\\trequire(_lte(removeAmount, supplierLiquidity), \\\"Removing more than total supplier liquidity\\\");\\n\\n\\t\\tCTokenAmount memory newAccountValue = _sub(truedUpAccountValue, removeAmount);\\n\\n\\t\\temit Remove(msg.sender, removeCTokenAmount, newAccountValue.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\t\\tsupplyAccounts[msg.sender].amount = newAccountValue;\\n\\n\\t\\tsupplierLiquidity = _sub(supplierLiquidity, removeAmount);\\n\\n\\t\\ttransferOut(msg.sender, removeAmount);\\n\\t}\\n\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(true, notionalAmount, maximumFixedRateMantissa);\\n\\t}\\n\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(false, notionalAmount, minFixedRateMantissa);\\n\\t}\\n\\n\\t/* @dev Opens a new interest rate swap\\n\\t * @param userPayingFixed : The user can choose if they want to receive fixed or pay fixed (the protocol will take the opposite side)\\n\\t * @param notionalAmount : The principal that interest rate payments will be based on\\n\\t * @param fixedRateLimitMantissa : The maximum (if payingFixed) or minimum (if receivingFixed) rate the swap should succeed at. Prevents frontrunning attacks.\\n\\t \\t* The amount of interest to pay over 2,102,400 blocks (~1 year), with 18 decimals of precision. Eg: 5% per block-year => 0.5e18.\\n\\t*/\\n\\tfunction openInternal(bool userPayingFixed, uint notionalAmount, uint fixedRateLimitMantissa) internal returns (bytes32 swapHash) {\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\t\\trequire(notionalAmount >= MIN_SWAP_NOTIONAL, \\\"Swap notional amount must exceed minimum\\\");\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityTemp = supplierLiquidity; // copy to memory for gas\\n\\t\\trequire(_lt(supplierLiquidityTemp, liquidityLimit), \\\"Open paused, above liquidity limit\\\");\\n\\t\\t\\n\\t\\t(Exp memory swapFixedRate, int rateFactorNew) = getSwapRate(userPayingFixed, notionalAmount, lockedCollateral, supplierLiquidityTemp, cTokenExchangeRate);\\n\\t\\tCTokenAmount memory userCollateralCTokens;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\trequire(swapFixedRate.mantissa <= fixedRateLimitMantissa, \\\"The fixed rate Rho would receive is above user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = _add(lockedCollateral, getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(_lte(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openPayFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\trequire(swapFixedRate.mantissa >= fixedRateLimitMantissa, \\\"The fixed rate Rho would pay is below user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = _add(lockedCollateral, getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(_lte(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openReceiveFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t}\\n\\n\\t\\tswapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t));\\n\\n\\t\\trequire(swaps[swapHash] == false, \\\"Duplicate swap\\\");\\n\\n\\t\\temit OpenSwap(\\n\\t\\t\\tswapHash,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t);\\n\\n\\t\\tswaps[swapHash] = true;\\n\\t\\trateFactor = rateFactorNew;\\n\\t\\ttransferIn(msg.sender, userCollateralCTokens);\\n\\t}\\n\\n\\n\\t// @dev User is paying fixed, protocol is receiving fixed\\n\\tfunction openPayFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalReceivingFixedNew = _add(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = _add(notionalPayingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksReceivingFixedNew = _add(parBlocksReceivingFixed, _mul(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRateReceivingNew = (avgFixedRateReceiving * notionalReceivingFixed + notionalAmount * swapFixedRate) / (notionalReceivingFixed + notionalAmount);*/\\n\\t\\tExp memory priorFixedReceivingRate = _mul(avgFixedRateReceiving, notionalReceivingFixed);\\n\\t\\tExp memory orderFixedReceivingRate = _mul(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRateReceivingNew = _div(_add(priorFixedReceivingRate, orderFixedReceivingRate), notionalReceivingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t// @dev User is receiving fixed, protocol is paying fixed\\n\\tfunction openReceiveFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalPayingFixedNew = _add(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = _add(notionalReceivingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksPayingFixedNew = _add(parBlocksPayingFixed, _mul(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRatePayingNew = (avgFixedRatePaying * notionalPayingFixed + notionalAmount * swapFixedRate) / (notionalPayingFixed + notionalAmount) */\\n\\t\\tExp memory priorFixedPayingRate = _mul(avgFixedRatePaying, notionalPayingFixed);\\n\\t\\tExp memory orderFixedPayingRate = _mul(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRatePayingNew = _div(_add(priorFixedPayingRate, orderFixedPayingRate), notionalPayingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t/* @dev Closes an existing swap, after the min swap duration. Float payment continues even if closed late.\\n\\t * Takes params from Open event.\\n\\t * Take caution not to unecessarily revert due to underflow / overflow, as uncloseable swaps are very dangerous.\\n\\t */\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) public override {\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tbytes32 swapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexInit,\\n\\t\\t\\tinitBlock,\\n\\t\\t\\tswapFixedRateMantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens,\\n\\t\\t\\towner\\n\\t\\t));\\n\\t\\trequire(swaps[swapHash] == true, \\\"No active swap found\\\");\\n\\t\\tuint swapDuration = _sub(getBlockNumber(), initBlock);\\n\\t\\trequire(swapDuration >= SWAP_MIN_DURATION, \\\"Premature close swap\\\");\\n\\t\\tExp memory benchmarkIndexRatio = _div(benchmarkIndexStored, _toExp(benchmarkIndexInit));\\n\\n\\t\\tCTokenAmount memory userCollateral = CTokenAmount({val: userCollateralCTokens});\\n\\t\\tExp memory swapFixedRate = _toExp(swapFixedRateMantissa);\\n\\n\\t\\tCTokenAmount memory userPayout;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\tuserPayout = closePayFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tuserPayout = closeReceiveFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tuint bal = cToken.balanceOf(address(this));\\n\\n\\t\\t// Payout is capped by total balance\\n\\t\\tif (userPayout.val > bal) userPayout = CTokenAmount({val: bal});\\n\\n\\t\\tuint lateBlocks = _sub(swapDuration, SWAP_MIN_DURATION);\\n\\t\\tCTokenAmount memory penalty = CTokenAmount(0);\\n\\n\\t\\tif (lateBlocks > CLOSE_GRACE_PERIOD_BLOCKS) {\\n\\t\\t\\tuint penaltyBlocks = lateBlocks - CLOSE_GRACE_PERIOD_BLOCKS;\\n\\t\\t\\tExp memory penaltyPercent = _mul(_toExp(CLOSE_PENALTY_PER_BLOCK_MANTISSA), penaltyBlocks);\\n\\t\\t\\tpenaltyPercent = ONE_EXP.mantissa > penaltyPercent.mantissa ? penaltyPercent : ONE_EXP; // maximum of 100% penalty\\n\\t\\t\\tpenalty = CTokenAmount(_mul(userPayout.val, penaltyPercent));\\n\\t\\t\\tuserPayout = _sub(userPayout, penalty);\\n\\t\\t}\\n\\n\\t\\temit CloseSwap(swapHash, owner, userPayout.val, penalty.val, benchmarkIndexStored.mantissa);\\n\\n\\t\\tswaps[swapHash] = false;\\n\\t\\ttransferOut(owner, userPayout);\\n\\t\\ttransferOut(msg.sender, penalty);\\n\\t}\\n\\n\\t// @dev User paid fixed, protocol paid fixed\\n\\tfunction closePayFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalReceivingFixedNew = _subToZero(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = _subToZero(notionalPayingFloat, _mul(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRateReceiving = avgFixedRateReceiving * notionalReceivingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRateReceivingNew;\\n\\t\\tif (notionalReceivingFixedNew == 0){\\n\\t\\t\\tavgFixedRateReceivingNew = _toExp(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = _subToZero(_mul(avgFixedRateReceiving, notionalReceivingFixed), _mul(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRateReceivingNew = _div(numerator, notionalReceivingFixedNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksReceivingFixedNew = _add(parBlocksReceivingFixed, _mul(notionalAmount, _sub(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(_mul(_mul(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(_mul(notionalAmount, _sub(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = _subToZero(_add(userCollateral, floatLeg), fixedLeg); // no underflows\\n\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t// @dev User received fixed, protocol paid fixed\\n\\tfunction closeReceiveFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalPayingFixedNew = _subToZero(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = _subToZero(notionalReceivingFloat, _mul(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRatePaying = avgFixedRatePaying * notionalPayingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRatePayingNew;\\n\\t\\tif (notionalPayingFixedNew == 0) {\\n\\t\\t\\tavgFixedRatePayingNew = _toExp(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = _subToZero(_mul(avgFixedRatePaying, notionalPayingFixed), _mul(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRatePayingNew = _div(numerator, notionalReceivingFloatNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksPayingFixedNew = _add(parBlocksPayingFixed, _mul(notionalAmount, _sub(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(_mul(_mul(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(_mul(notionalAmount, _sub(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = _subToZero(_add(userCollateral, fixedLeg), floatLeg);\\n\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t/* @dev Called internally at the beginning of external swap and liquidity provider functions.\\n\\t * WRITES TO STORAGE\\n\\t * Accounts for interest rate payments and adjust collateral requirements with the passage of time.\\n\\t * @return lockedCollateralNew : The amount of collateral the protocol needs to keep locked.\\n\\t */\\n\\tfunction accrue(Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory) {\\n\\t\\trequire(getBlockNumber() >= lastAccrualBlock, \\\"Block number decreasing\\\");\\n\\t\\tuint accruedBlocks = getBlockNumber() - lastAccrualBlock;\\n\\t\\t(CTokenAmount memory lockedCollateralNew, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) = getLockedCollateral(accruedBlocks, cTokenExchangeRate);\\n\\n\\t\\tif (accruedBlocks == 0) {\\n\\t\\t\\treturn lockedCollateralNew;\\n\\t\\t}\\n\\n\\t\\tExp memory benchmarkIndexNew = getBenchmarkIndex();\\n\\t\\tExp memory benchmarkIndexRatio = _div(benchmarkIndexNew, benchmarkIndexStored);\\n\\t\\tExp memory floatRate = _sub(benchmarkIndexRatio, ONE_EXP);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityNew = getSupplierLiquidity(accruedBlocks, floatRate, cTokenExchangeRate);\\n\\n\\t\\t// supplyIndex *= supplierLiquidityNew / supplierLiquidity\\n\\t\\tuint supplyIndexNew = supplyIndex;\\n\\t\\tif (supplierLiquidityNew.val != 0) {\\n\\t\\t\\tsupplyIndexNew = _div(_mul(supplyIndex, supplierLiquidityNew), supplierLiquidity);\\n\\t\\t}\\n\\n\\t\\tuint notionalPayingFloatNew = _mul(notionalPayingFloat, benchmarkIndexRatio);\\n\\t\\tuint notionalReceivingFloatNew = _mul(notionalReceivingFloat, benchmarkIndexRatio);\\n\\n\\t\\t/** Apply Effects **/\\n\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\t\\tsupplyIndex = supplyIndexNew;\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\n\\t\\tbenchmarkIndexStored = benchmarkIndexNew;\\n\\t\\tlastAccrualBlock = getBlockNumber();\\n\\n\\t\\temit Accrue(supplierLiquidityNew.val, lockedCollateralNew.val);\\n\\t\\treturn lockedCollateralNew;\\n\\t}\\n\\n\\tfunction transferIn(address from, CTokenAmount memory cTokenAmount) internal {\\n\\t\\trequire(cToken.transferFrom(from, address(this), cTokenAmount.val) == true, \\\"Transfer In Failed\\\");\\n\\t}\\n\\n\\tfunction transferOut(address to, CTokenAmount memory cTokenAmount) internal {\\n\\t\\tif (cTokenAmount.val > 0) {\\n\\t\\t\\trequire(cToken.transfer(to, cTokenAmount.val), \\\"Transfer Out failed\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t// ** PUBLIC PURE HELPERS ** //\\n\\n\\tfunction toCTokens(uint amount, Exp memory cTokenExchangeRate) public pure returns (CTokenAmount memory) {\\n\\t\\tuint cTokenAmount = _div(amount, cTokenExchangeRate);\\n\\t\\treturn CTokenAmount({val: cTokenAmount});\\n\\t}\\n\\n\\tfunction toUnderlying(CTokenAmount memory amount, Exp memory cTokenExchangeRate) public pure returns (uint) {\\n\\t\\treturn _mul(amount.val, cTokenExchangeRate);\\n\\t}\\n\\n\\t// *** PUBLIC VIEW GETTERS *** //\\n\\n\\t// @dev Calculate protocol locked collateral and parBlocks, which is a measure of the fixed rate credit/debt.\\n\\t// * Uses int to keep negatives, for correct late blocks calc when a single swap is outstanding\\n\\tfunction getLockedCollateral(uint accruedBlocks, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory lockedCollateral, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) {\\n\\t\\tparBlocksReceivingFixedNew = _sub(parBlocksReceivingFixed, _mul(accruedBlocks, notionalReceivingFixed));\\n\\t\\tparBlocksPayingFixedNew = _sub(parBlocksPayingFixed, _mul(accruedBlocks, notionalPayingFixed));\\n\\n\\t\\t// Par blocks can be negative during the first or last ever swap, so floor them to 0\\n\\t\\tuint minFloatToReceive = _mul(_toUint(parBlocksPayingFixedNew), minFloatRate);\\n\\t\\tuint maxFloatToPay = _mul(_toUint(parBlocksReceivingFixedNew), maxFloatRate);\\n\\n\\t\\tuint fixedToReceive = _mul(_toUint(parBlocksReceivingFixedNew), avgFixedRateReceiving);\\n\\t\\tuint fixedToPay = _mul(_toUint(parBlocksPayingFixedNew), avgFixedRatePaying);\\n\\n\\t\\tuint minCredit = _add(fixedToReceive, minFloatToReceive);\\n\\t\\tuint maxDebt = _add(fixedToPay, maxFloatToPay);\\n\\n\\t\\tif (maxDebt > minCredit) {\\n\\t\\t\\tlockedCollateral = toCTokens(_sub(maxDebt, minCredit), cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\tlockedCollateral = CTokenAmount({val:0});\\n\\t\\t}\\n\\t}\\n\\n\\t/* @dev Calculate protocol P/L by adding the cashflows since last accrual.\\n\\t * \\t\\tsupplierLiquidity += fixedReceived + floatReceived - fixedPaid - floatPaid\\n\\t */\\n\\tfunction getSupplierLiquidity(uint accruedBlocks, Exp memory floatRate, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory supplierLiquidityNew) {\\n\\t\\tuint floatPaid = _mul(notionalPayingFloat, floatRate);\\n\\t\\tuint floatReceived = _mul(notionalReceivingFloat, floatRate);\\n\\t\\tuint fixedPaid = _mul(accruedBlocks, _mul(notionalPayingFixed, avgFixedRatePaying));\\n\\t\\tuint fixedReceived = _mul(accruedBlocks, _mul(notionalReceivingFixed, avgFixedRateReceiving));\\n\\n\\t\\tCTokenAmount memory rec = toCTokens(_add(fixedReceived, floatReceived), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory paid = toCTokens(_add(fixedPaid, floatPaid), cTokenExchangeRate);\\n\\t\\tsupplierLiquidityNew = _subToZero(_add(supplierLiquidity, rec), paid);\\n\\t}\\n\\n\\t// @dev Get the rate for incoming swaps\\n\\tfunction getSwapRate(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tCTokenAmount memory lockedCollateral,\\n\\t\\tCTokenAmount memory supplierLiquidity_,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) public view returns (Exp memory, int) {\\n\\t\\t(uint ratePerBlockMantissa, int rateFactorNew) = interestRateModel.getSwapRate(\\n\\t\\t\\trateFactor,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\torderNotional,\\n\\t\\t\\ttoUnderlying(lockedCollateral, cTokenExchangeRate),\\n\\t\\t\\ttoUnderlying(supplierLiquidity_, cTokenExchangeRate)\\n\\t\\t);\\n\\t\\treturn (_toExp(ratePerBlockMantissa), rateFactorNew);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the payFixed leg of a swap paying fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (swapFixedRate - minFloatRate)\\n\\tfunction getPayFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = _sub(fixedRate, minFloatRate);\\n\\t\\tuint amt = _mul(_mul(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the receiveFixed leg of a swap receiving fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (maxFloatRate - swapFixedRate)\\n\\tfunction getReceiveFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = _sub(maxFloatRate, fixedRate);\\n\\t\\tuint amt = _mul(_mul(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev Interpolates to get the current borrow index from a compound CToken (or some other similar interface)\\n\\tfunction getBenchmarkIndex() public view returns (Exp memory) {\\n\\t\\tExp memory borrowIndex = _toExp(cToken.borrowIndex());\\n\\t\\trequire(borrowIndex.mantissa != 0, \\\"Benchmark index is zero\\\");\\n\\t\\tuint accrualBlockNumber = cToken.accrualBlockNumber();\\n\\t\\trequire(getBlockNumber() >= accrualBlockNumber, \\\"Bn decreasing\\\");\\n\\t\\tuint blockDelta = _sub(getBlockNumber(), accrualBlockNumber);\\n\\n\\t\\tif (blockDelta == 0) {\\n\\t\\t\\treturn borrowIndex;\\n\\t\\t} else {\\n\\t\\t\\tExp memory borrowRateMantissa = _toExp(cToken.borrowRatePerBlock());\\n\\t\\t\\tExp memory simpleInterestFactor = _mul(borrowRateMantissa, blockDelta);\\n\\t\\t\\treturn _mul(borrowIndex, _add(simpleInterestFactor, ONE_EXP));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getExchangeRate() public view returns (Exp memory) {\\n\\t\\treturn _toExp(cToken.exchangeRateStored());\\n\\t}\\n\\n\\tfunction getBlockNumber() public view virtual returns (uint) {\\n\\t\\treturn block.number;\\n\\t}\\n\\n\\t/** ADMIN FUNCTIONS **/\\n\\n\\tfunction _setInterestRateModel(InterestRateModelInterface newModel) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set interest rate model\\\");\\n\\t\\trequire(newModel != interestRateModel, \\\"Resetting to same model\\\");\\n\\t\\temit SetInterestRateModel(address(newModel), address(interestRateModel));\\n\\t\\tinterestRateModel = newModel;\\n\\t}\\n\\n\\tfunction _setCollateralRequirements(uint minFloatRateMantissa_, uint maxFloatRateMantissa_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set collateral requirements\\\");\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\temit SetCollateralRequirements(minFloatRateMantissa_, maxFloatRateMantissa_);\\n\\t\\tminFloatRate = _toExp(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = _toExp(maxFloatRateMantissa_);\\n\\t}\\n\\n\\tfunction _setLiquidityLimit(uint limit_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set liqiudity limit\\\");\\n\\t\\temit SetLiquidityLimit(limit_);\\n\\t\\tliquidityLimit = CTokenAmount({val: limit_});\\n\\t}\\n\\n\\tfunction _pause(bool isPaused_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to pause\\\");\\n\\t\\trequire(isPaused_ != isPaused, \\\"Must change isPaused\\\");\\n\\t\\temit SetPause(isPaused_);\\n\\t\\tisPaused = isPaused_;\\n\\t}\\n\\n\\tfunction _transferComp(address dest, uint amount) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to transfer comp\\\");\\n\\t\\temit CompTransferred(dest, amount);\\n\\t\\tcomp.transfer(dest, amount);\\n\\t}\\n\\n\\tfunction _delegateComp(address delegatee) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to delegate comp\\\");\\n\\t\\temit CompDelegated(delegatee);\\n\\t\\tcomp.delegate(delegatee);\\n\\t}\\n\\n\\tfunction _changeAdmin(address admin_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to change admin\\\");\\n\\t\\temit AdminChanged(admin, admin_);\\n\\t\\tadmin = admin_;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xba5537c4bfd0b58acb50c9619c3eb173343af4d88ebe599094a2860ed6796aaa\"},\"contracts/RhoInterfaces.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"},\"contracts/Types.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\"keccak256\":\"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"},\"contracts/test/MockRho.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"../Rho.sol\\\";\\n\\ncontract MockRho is Rho {\\n\\n\\tuint public blockNumber = 100;\\n\\n\\tconstructor (\\n\\t\\tInterestRateModelInterface interestRateModel_,\\n\\t\\tCTokenInterface cToken_,\\n\\t\\tCompInterface comp_,\\n\\t\\tuint minFloatRateMantissa_,\\n\\t\\tuint maxFloatRateMantissa_,\\n\\t\\tuint swapMinDuration_,\\n\\t\\tuint supplyMinDuration_,\\n\\t\\taddress admin_,\\n\\t\\tuint liquidityLimitCTokens_\\n\\t)\\n\\t\\tRho(\\n\\t\\t\\tinterestRateModel_,\\n\\t\\t\\tcToken_,\\n\\t\\t\\tcomp_,\\n\\t\\t\\tminFloatRateMantissa_,\\n\\t\\t\\tmaxFloatRateMantissa_,\\n\\t\\t\\tswapMinDuration_,\\n\\t\\t\\tsupplyMinDuration_,\\n\\t\\t\\tadmin_,\\n\\t\\t\\tliquidityLimitCTokens_\\n\\t\\t)\\n\\t\\tpublic {}\\n\\n\\tfunction setBlockNumber(uint blockNumber_) public returns (uint) {\\n\\t\\tblockNumber = blockNumber_;\\n\\t}\\n\\n\\tfunction getBlockNumber() public view override returns (uint) {\\n\\t\\treturn blockNumber;\\n\\t}\\n\\n\\tfunction harnessAccrueInterest() public returns (CTokenAmount memory lockedCollateralNew){\\n\\t\\treturn accrue(getExchangeRate());\\n\\t}\\n\\n\\tfunction advanceBlocks(uint blocks) public {\\n\\t\\tblockNumber = blockNumber + blocks;\\n\\t}\\n\\n\\tfunction advanceBlocksProtocol(uint blocks) public {\\n\\t\\tadvanceBlocks(blocks);\\n\\n\\t\\t(bool worked, bytes memory _) = address(cToken).call(abi.encodeWithSignature(\\\"advanceBlocks(uint256)\\\", blocks));\\n\\t\\trequire(worked == true, \\\"Advance blocks didnt work\\\");\\n\\t\\t_;\\n\\t}\\n}\\n\",\"keccak256\":\"0x7c74258789e4a909bb5d251aa64935f2236dee7f5302934923abd186cfc490f5\"}},\"version\":1}"},"contracts/test/SafeMath.sol:SafeMath":{"abi":"[]","bin":"60566023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220309629dcc657bfd1b4afb2cd6295e1356e134278e4ec6053aa2c4f99eec3f55064736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Wrappers over Solidity's arithmetic operations with added overflow checks. Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs, because programmers usually assume that an overflow raises an error, which is the standard behavior in high level programming languages. `SafeMath` restores this intuition by reverting the transaction when an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.\",\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/test/SafeMath.sol\":\"SafeMath\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/test/SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xabba6407e3cc0e14aa98d71eac7c59513b9b68b4ac734293ac2dbab9d5cb3dfb\"}},\"version\":1}"},"contracts/test/StandardToken.sol:BasicToken":{"abi":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","bin":"608060405234801561001057600080fd5b5061037e806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806318160ddd1461004657806370a0823114610060578063a9059cbb14610086575b600080fd5b61004e6100c6565b60408051918252519081900360200190f35b61004e6004803603602081101561007657600080fd5b50356001600160a01b03166100cc565b6100b26004803603604081101561009c57600080fd5b506001600160a01b0381351690602001356100e7565b604080519115158252519081900360200190f35b60015490565b6001600160a01b031660009081526020819052604090205490565b60006001600160a01b0383166100fc57600080fd5b33600090815260208190526040902054821115610160576040805162461bcd60e51b815260206004820152601e60248201527f5472616e736665723a20696e73756666696369656e742062616c616e63650000604482015290519081900360640190fd5b33600090815260208190526040902054610180908363ffffffff61020e16565b33600090815260208190526040808220929092556001600160a01b038516815220546101b2908363ffffffff61025716565b6001600160a01b038416600081815260208181526040918290209390935580518581529051919233927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a350600192915050565b600061025083836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f7700008152506102b1565b9392505050565b600082820183811015610250576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b600081848411156103405760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156103055781810151838201526020016102ed565b50505050905090810190601f1680156103325780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b50505090039056fea2646970667358221220b86522538d190a91f11a49199b9a7cef1ed1fb1a33bc67294bad3616ca65b94864736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Basic version of StandardToken, with no allowances.\",\"methods\":{\"balanceOf(address)\":{\"details\":\"Gets the balance of the specified address.\",\"params\":{\"_owner\":\"The address to query the the balance of.\"},\"returns\":{\"_0\":\"An uint256 representing the amount owned by the passed address.\"}},\"totalSupply()\":{\"details\":\"Total number of tokens in existence\"},\"transfer(address,uint256)\":{\"details\":\"Transfer token for a specified address\",\"params\":{\"_to\":\"The address to transfer to.\",\"_value\":\"The amount to be transferred.\"}}},\"title\":\"Basic token\"},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/test/StandardToken.sol\":\"BasicToken\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/test/SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xabba6407e3cc0e14aa98d71eac7c59513b9b68b4ac734293ac2dbab9d5cb3dfb\"},\"contracts/test/StandardToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\nabstract contract ERC20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n    function balanceOf(address who) public view virtual returns (uint256);\\n    function transfer(address to, uint256 value) public virtual returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) balances;\\n\\n    uint256 totalSupply_;\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() public view override returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        require(_to != address(0));\\n        require(_value <= balances[msg.sender], \\\"Transfer: insufficient balance\\\");\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param _owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address _owner) public view override returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n}\\n\\n\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\nabstract contract ERC20 is ERC20Basic {\\n    function allowance(address owner, address spender) public view virtual returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\\n    function approve(address spender, uint256 value) public virtual returns (bool);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/issues/20\\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n    mapping (address => mapping (address => uint256)) internal allowed;\\n\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(_to != address(0), \\\"TransferFrom: Can't send to address zero\\\");\\n        require(_value <= balances[_from], \\\"TransferFrom: Inadequate balance\\\");\\n        require(_value <= allowed[_from][msg.sender], \\\"TransferFrom: Inadequate allowance\\\");\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param _spender The address which will spend the funds.\\n     * @param _value The amount of tokens to be spent.\\n     */\\n    function approve(address _spender, uint256 _value) public override returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n     )\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (\\n            allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue > oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x33a81ce8e70f59fe7a0d01872dc70e6c46fe7b90dd983c960f074ee907feb93e\"}},\"version\":1}"},"contracts/test/StandardToken.sol:ERC20":{"abi":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","bin":"","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"see https://github.com/ethereum/EIPs/issues/20\",\"methods\":{},\"title\":\"ERC20 interface\"},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/test/StandardToken.sol\":\"ERC20\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/test/SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xabba6407e3cc0e14aa98d71eac7c59513b9b68b4ac734293ac2dbab9d5cb3dfb\"},\"contracts/test/StandardToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\nabstract contract ERC20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n    function balanceOf(address who) public view virtual returns (uint256);\\n    function transfer(address to, uint256 value) public virtual returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) balances;\\n\\n    uint256 totalSupply_;\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() public view override returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        require(_to != address(0));\\n        require(_value <= balances[msg.sender], \\\"Transfer: insufficient balance\\\");\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param _owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address _owner) public view override returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n}\\n\\n\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\nabstract contract ERC20 is ERC20Basic {\\n    function allowance(address owner, address spender) public view virtual returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\\n    function approve(address spender, uint256 value) public virtual returns (bool);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/issues/20\\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n    mapping (address => mapping (address => uint256)) internal allowed;\\n\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(_to != address(0), \\\"TransferFrom: Can't send to address zero\\\");\\n        require(_value <= balances[_from], \\\"TransferFrom: Inadequate balance\\\");\\n        require(_value <= allowed[_from][msg.sender], \\\"TransferFrom: Inadequate allowance\\\");\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param _spender The address which will spend the funds.\\n     * @param _value The amount of tokens to be spent.\\n     */\\n    function approve(address _spender, uint256 _value) public override returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n     )\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (\\n            allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue > oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x33a81ce8e70f59fe7a0d01872dc70e6c46fe7b90dd983c960f074ee907feb93e\"}},\"version\":1}"},"contracts/test/StandardToken.sol:ERC20Basic":{"abi":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","bin":"","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Simpler version of ERC20 interface See https://github.com/ethereum/EIPs/issues/179\",\"methods\":{},\"title\":\"ERC20Basic\"},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/test/StandardToken.sol\":\"ERC20Basic\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/test/SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xabba6407e3cc0e14aa98d71eac7c59513b9b68b4ac734293ac2dbab9d5cb3dfb\"},\"contracts/test/StandardToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\nabstract contract ERC20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n    function balanceOf(address who) public view virtual returns (uint256);\\n    function transfer(address to, uint256 value) public virtual returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) balances;\\n\\n    uint256 totalSupply_;\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() public view override returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        require(_to != address(0));\\n        require(_value <= balances[msg.sender], \\\"Transfer: insufficient balance\\\");\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param _owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address _owner) public view override returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n}\\n\\n\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\nabstract contract ERC20 is ERC20Basic {\\n    function allowance(address owner, address spender) public view virtual returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\\n    function approve(address spender, uint256 value) public virtual returns (bool);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/issues/20\\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n    mapping (address => mapping (address => uint256)) internal allowed;\\n\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(_to != address(0), \\\"TransferFrom: Can't send to address zero\\\");\\n        require(_value <= balances[_from], \\\"TransferFrom: Inadequate balance\\\");\\n        require(_value <= allowed[_from][msg.sender], \\\"TransferFrom: Inadequate allowance\\\");\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param _spender The address which will spend the funds.\\n     * @param _value The amount of tokens to be spent.\\n     */\\n    function approve(address _spender, uint256 _value) public override returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n     )\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (\\n            allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue > oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x33a81ce8e70f59fe7a0d01872dc70e6c46fe7b90dd983c960f074ee907feb93e\"}},\"version\":1}"},"contracts/test/StandardToken.sol:StandardToken":{"abi":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","bin":"608060405234801561001057600080fd5b50610932806100206000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c806370a082311161005b57806370a0823114610149578063a9059cbb1461016f578063d73dd6231461019b578063dd62ed3e146101c757610088565b8063095ea7b31461008d57806318160ddd146100cd57806323b872dd146100e7578063661884631461011d575b600080fd5b6100b9600480360360408110156100a357600080fd5b506001600160a01b0381351690602001356101f5565b604080519115158252519081900360200190f35b6100d561025b565b60408051918252519081900360200190f35b6100b9600480360360608110156100fd57600080fd5b506001600160a01b03813581169160208101359091169060400135610261565b6100b96004803603604081101561013357600080fd5b506001600160a01b038135169060200135610482565b6100d56004803603602081101561015f57600080fd5b50356001600160a01b0316610572565b6100b96004803603604081101561018557600080fd5b506001600160a01b03813516906020013561058d565b6100b9600480360360408110156101b157600080fd5b506001600160a01b0381351690602001356106b4565b6100d5600480360360408110156101dd57600080fd5b506001600160a01b038135811691602001351661074d565b3360008181526002602090815260408083206001600160a01b038716808552908352818420869055815186815291519394909390927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a350600192915050565b60015490565b60006001600160a01b0383166102a85760405162461bcd60e51b81526004018080602001828103825260288152602001806108d56028913960400191505060405180910390fd5b6001600160a01b038416600090815260208190526040902054821115610315576040805162461bcd60e51b815260206004820181905260248201527f5472616e7366657246726f6d3a20496e61646571756174652062616c616e6365604482015290519081900360640190fd5b6001600160a01b03841660009081526002602090815260408083203384529091529020548211156103775760405162461bcd60e51b81526004018080602001828103825260228152602001806108b36022913960400191505060405180910390fd5b6001600160a01b0384166000908152602081905260409020546103a0908363ffffffff61077816565b6001600160a01b0380861660009081526020819052604080822093909355908516815220546103d5908363ffffffff6107c116565b6001600160a01b03808516600090815260208181526040808320949094559187168152600282528281203382529091522054610417908363ffffffff61077816565b6001600160a01b03808616600081815260026020908152604080832033845282529182902094909455805186815290519287169391927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef929181900390910190a35060019392505050565b3360009081526002602090815260408083206001600160a01b0386168452909152812054808311156104d7573360009081526002602090815260408083206001600160a01b038816845290915281205561050c565b6104e7818463ffffffff61077816565b3360009081526002602090815260408083206001600160a01b03891684529091529020555b3360008181526002602090815260408083206001600160a01b0389168085529083529281902054815190815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a35060019392505050565b6001600160a01b031660009081526020819052604090205490565b60006001600160a01b0383166105a257600080fd5b33600090815260208190526040902054821115610606576040805162461bcd60e51b815260206004820152601e60248201527f5472616e736665723a20696e73756666696369656e742062616c616e63650000604482015290519081900360640190fd5b33600090815260208190526040902054610626908363ffffffff61077816565b33600090815260208190526040808220929092556001600160a01b03851681522054610658908363ffffffff6107c116565b6001600160a01b038416600081815260208181526040918290209390935580518581529051919233927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a350600192915050565b3360009081526002602090815260408083206001600160a01b03861684529091528120546106e8908363ffffffff6107c116565b3360008181526002602090815260408083206001600160a01b0389168085529083529281902085905580519485525191937f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929081900390910190a350600192915050565b6001600160a01b03918216600090815260026020908152604080832093909416825291909152205490565b60006107ba83836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f77000081525061081b565b9392505050565b6000828201838110156107ba576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b600081848411156108aa5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561086f578181015183820152602001610857565b50505050905090810190601f16801561089c5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b50505090039056fe5472616e7366657246726f6d3a20496e616465717561746520616c6c6f77616e63655472616e7366657246726f6d3a2043616e27742073656e6420746f2061646472657373207a65726fa2646970667358221220ff0d8ea41dd040c33c5c8b972ffc8c80116a2c3c0ef84fb24b8161cfcc3d7fa064736f6c634300060a0033","metadata":"{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implementation of the basic standard token. https://github.com/ethereum/EIPs/issues/20 Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Function to check the amount of tokens that an owner allowed to a spender.\",\"params\":{\"_owner\":\"address The address which owns the funds.\",\"_spender\":\"address The address which will spend the funds.\"},\"returns\":{\"_0\":\"A uint256 specifying the amount of tokens still available for the spender.\"}},\"approve(address,uint256)\":{\"details\":\"Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\",\"params\":{\"_spender\":\"The address which will spend the funds.\",\"_value\":\"The amount of tokens to be spent.\"}},\"balanceOf(address)\":{\"details\":\"Gets the balance of the specified address.\",\"params\":{\"_owner\":\"The address to query the the balance of.\"},\"returns\":{\"_0\":\"An uint256 representing the amount owned by the passed address.\"}},\"decreaseApproval(address,uint256)\":{\"details\":\"Decrease the amount of tokens that an owner allowed to a spender. approve should be called when allowed[_spender] == 0. To decrement allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined) From MonolithDAO Token.sol\",\"params\":{\"_spender\":\"The address which will spend the funds.\",\"_subtractedValue\":\"The amount of tokens to decrease the allowance by.\"}},\"increaseApproval(address,uint256)\":{\"details\":\"Increase the amount of tokens that an owner allowed to a spender. approve should be called when allowed[_spender] == 0. To increment allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined) From MonolithDAO Token.sol\",\"params\":{\"_addedValue\":\"The amount of tokens to increase the allowance by.\",\"_spender\":\"The address which will spend the funds.\"}},\"totalSupply()\":{\"details\":\"Total number of tokens in existence\"},\"transfer(address,uint256)\":{\"details\":\"Transfer token for a specified address\",\"params\":{\"_to\":\"The address to transfer to.\",\"_value\":\"The amount to be transferred.\"}},\"transferFrom(address,address,uint256)\":{\"details\":\"Transfer tokens from one address to another\",\"params\":{\"_from\":\"address The address which you want to send tokens from\",\"_to\":\"address The address which you want to transfer to\",\"_value\":\"uint256 the amount of tokens to be transferred\"}}},\"title\":\"Standard ERC20 token\"},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/test/StandardToken.sol\":\"StandardToken\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/test/SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xabba6407e3cc0e14aa98d71eac7c59513b9b68b4ac734293ac2dbab9d5cb3dfb\"},\"contracts/test/StandardToken.sol\":{\"content\":\"pragma solidity ^0.6.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\nabstract contract ERC20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n    function balanceOf(address who) public view virtual returns (uint256);\\n    function transfer(address to, uint256 value) public virtual returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) balances;\\n\\n    uint256 totalSupply_;\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() public view override returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        require(_to != address(0));\\n        require(_value <= balances[msg.sender], \\\"Transfer: insufficient balance\\\");\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param _owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address _owner) public view override returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n}\\n\\n\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\nabstract contract ERC20 is ERC20Basic {\\n    function allowance(address owner, address spender) public view virtual returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\\n    function approve(address spender, uint256 value) public virtual returns (bool);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/issues/20\\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n    mapping (address => mapping (address => uint256)) internal allowed;\\n\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(_to != address(0), \\\"TransferFrom: Can't send to address zero\\\");\\n        require(_value <= balances[_from], \\\"TransferFrom: Inadequate balance\\\");\\n        require(_value <= allowed[_from][msg.sender], \\\"TransferFrom: Inadequate allowance\\\");\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param _spender The address which will spend the funds.\\n     * @param _value The amount of tokens to be spent.\\n     */\\n    function approve(address _spender, uint256 _value) public override returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n     )\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseApproval(\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = (\\n            allowed[msg.sender][_spender].add(_addedValue));\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param _spender The address which will spend the funds.\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseApproval(\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue > oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x33a81ce8e70f59fe7a0d01872dc70e6c46fe7b90dd983c960f074ee907feb93e\"}},\"version\":1}"}},"version":"0.6.10+commit.00c0fcaf.Darwin.appleclang"}
